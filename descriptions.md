при создании репо
скопировать git remote add origin <название репо>
потом локально git init
и создать удаленный репо скопированной командой

Командой git status можно увидеть какие файлы распознает гит для отправки в удаленный репо

Cоздание собственного сниппета для быстрого разворачивания функционального реакт компонента.
В Webstorm. Settings -> Editor -> Live template. Там user/. (добавить свой), ввести название команды.
Сниппет:

import classNames from 'shared/helpers/styles/classNames/classNames';
import cls from './$FILE_NAME$.module.scss';

interface $FILE_NAME$Props {
    className?: string;
}

export const $FILE_NAME$ = (props: $FILE_NAME$Props) => {
    const {
        className,
    } = props;
    return (
        <div classname={classNames(cls.$FILE_NAME$, {}, [className])}>

        </div>
    );
};

Правой кнопкой мыши выделяется переменная, настройка. Выбрать fileNameWithoutExtension().
Выбрать контекст JavaScrip/TypeScript (при наличии React JS/TS).

Сниппет для .vscode/rc.code-snippets

{
"React Functional Component": {
"prefix": [
"rc"
],
"body": [
"import { classNames } from \"shared/lib/classNames/classNames\";",
"import cls from \"./$TM_FILENAME_BASE.module.scss\";",
"",
"interface $TM_FILENAME_BASE Props {",
"  className?: string;",
"}",
"",
"export const $TM_FILENAME_BASE = ({ className }: $TM_FILENAME_BASE Props) => {",
"  return (",
"    <div className={classNames(cls.$TM_FILENAME_BASE, {}, [className])}>",
"      $2",
"    </div>",
"  )",
"};",
""
],
"description": "React Functional Component"
}
}

В какой-то момент я начал использовать yarn вместо npm, т.к. с ним комфортнее работать со старыми версиями пакетов.
Возникает меньше конфликтов версий, более стабильная работа.

18. Настройка eslint для ts файлов
К настройкам правил нужно относиться серьезно и основательно
npm install --save-dev eslint
npm init @eslint/config
Для настройки правил eslint, наводим на ошибку линта, копируем название правила и гуглим этот rule,
потом вставляем эти правила в .eslintrc.js в поле rules
Если мы знаем что это за правило и оно нам не нужно,
то можно просто указать его название в ключе rules со значением 'off'.
Либо можно сменить отображение на предупреждение (значение 'warn')
Команда eslint "**/*.{ts,tsx}" --fix должна фиксить все ошибки на проекте
Если осознанно хочется заблокировать правило в одном месте, можно над ним вставлять комментарий 
// eslint-disable-next-line <название правила>

19. Stylelint для настройки правил css файлов, конфиг в .stylelintrc.json
Для подсветки текста в jsx разметки для i18n (что нужен перевод) установлен eslint-plugin-i18next
в конфиге .eslintrc.js нужно добавить murkupOnly: true
в plugins: i18next
в extends: plugin:i18next/recommended

20. Jest - библиотека для тестирования js кода (jsdom)
Можно написать jest --init для автонастройки. Также нужно установить @types/jest.
Чтобы jest понимал ts, нужно установить @babel/preset-typescript. и обновить конфиг @babel
Для тестирования, рядом с тестируемыми файлами создаем файл с расширением .test.ts
Можно запускать тесты только для 1 файла через пробел после скрипта <название файла>

21. Несуществующий роут, page компонент для роута, которого нет в Routes
loader cкопирован с источника https://loading.io/css/

22. ErrorBoundary не отлавливает ошибки, которые происходят в асинхронном коде, в событиях,
при server-side rendering и ошибки, которые возникают в самом ErrorBoundary.
В componentDidCatch можно использовать свой сервис для логирования, а не console.log.
В классовом компоненте нужно испольщовать HOK withTranslation from react-i18next

23. Webpack Bundle Analyzer - пакет для анализа бандла вебпака
Нужно добавить плагин BundleAnalyzerPlugin в конфиг
После этого, при запуске приложения, во второй вкладке ана порту :8888 откроется страница с описаниями пакетов, 
которые используются в приложении.
Если запускать сборки run build:dev run build:prod, то так же будет открываться страница с пакетами билдов
Слева сверху можно посмотреть вес чанков в разных режимах

24. React testing library. Файлы с тестами желательно располагать рядом с компонентами или функциями
Чтобы jest тесты работали с абсолютными импортами добавили в jest.config modulePaths: ['<rootDir>src']
возле jest config создали файл setupTests.ts (при create-react-app он так и называется)
в jest.config добавили setupFilesAfterEnv: ['<rootDir>config/jest/setupTests.ts'],
в tsconfig добавили "include": ["./config/jest/setupTests.ts"],
после этого TS подхватывает все методы при написании кода в рантайме
так же нужно установить пресет для парсинга tsx - @babel/preset-typescript и @babel/preset-react(эта версия не нашлась, возможна ошибка)
Для парсинга jest`ом css модулей установили identity-obj-proxy
в конфиге jest добавили moduleNameMapper: { '\\.s?css$': 'identity-obj-proxy' }
В babel конфиге изменили ["@babel/preset-react", {"runtime": "automatic"}]
Можно добавить в тестах screen.debug(); Тогда в консоли отобразятся атрибуты элемента
Для парсинга svg в jest.config в поле moduleNameMapper добавили '\\.svg': path.resolve(__dirname, 'jestEmptyComponent.tsx'),
Грубо говоря это мок, который будет использоваться для всех импортов в которых используется svg. Создали рядом с конфигом этот компонент
в setupTests.ts добавили import 'regenerator-runtime/runtime'; и установили зависимость regenerator-runtime
В shared/config/i18n дабавили i18nForTests.ts (скопировали из https://react.i18next.com/misc/testing#example-configuration-for-testing  и немного изменили)
создали в shared/lib/test/renderWithTranslation helper
Эта функция оборачивает тестируемый компонент в обертку и добавляет нужную конфигурация для переводов

25. Storybook. Инициализация npx sb init --builder webpack5
После инициализации появится папка .storybook (конфиг).
И появятся 2 новых скрипта в package.json для запуска и сборки storybook.
Так же появится директория src/stories. В будущем будут писаться свои stories.
Можно будет передавать в компоненты разные пропсы.
Вынесли конфигурацию с src/.storybook в src/config/storybook
Изменили в конфиге относительные пути
добавили в скрипты флаг -c ./config/storybook с новым (не дефолтным) путем до конфига
Новые сторисы создаются в папке компонента рядом с файлом компонента 
с расширением <component-name>.stories.tsx (как в main конфиге для сторис)
Перенесли код из файла сторис примера в нащ новый файл, сгенеренную папку src/stories удалили
По сути большенство это копипаста и переписывание пропсов
в meta.title указывается путь и азвание файла (title: 'shared/Button') - shared слой и Button компонент
Так же storybook по-дефолту не понимает настроенные на проекте абсолютные пути в импортах, нужна доп настройка
У сторибука есть своя конфигурация для вебпака. На занятии создавали сами (файл webpack.config.ts), 
это обычный файл конфига для вебпак, но отдельный
Я поставил новую 8 версию и она была уже после инициализации сторибука (находится возле остальных файлов конфига)
У меня конфиг уже был рабочий, с настройкой абсолютных путей config.resolve.modules.push(paths.src);
Так же нужна настройка CSS модулей для сторибука (по-дефолту был импорт в конфиге, но не адаптирован под мой конфиг)
В config/build/buildLoaders.ts есть cssLoader. Решили вынести лоадеры в отдельную папку config/build/loaders
Вынесли туда в файл buildCssLoader.ts
Если верстка компонента в сторибуке не соответствует, можно так же открыть девтулзы и посмотреть DOM 
Storybook не подтягиев ссылки на переменные препроцессора стилей по дефолту. 
Чтоб не импортировать в каждый сторис файл с переменными в стилях
нужно в конфиге сторибука preview.ts добавить decorator,
который будет глобально оборачивать каждый сторибук компонент
В shared/config создаем папку storybook.
Добавили декоратор темы в preview.ts (Глобадьно применяется LIGHT, но в каждый сторис можно добавлять другой).
Так же в вебпак конфиг сторис нужно добавлять svg модуль (т.к. это отдельный конфиг).
Сторибук будет полезен разработчикам, они могут ознакомиться с компонентами
Так же с помощью сторибука можно снимать скриншотные тесты и делать регрессионное тестирование интерфейса на изменение
Добавили декоратор роутера
Для pages так же сделали сторисы

26. Скриншотные тесты. Есть платные и бесплатные библиотеки. Тут используется Loki. 
Инициализация - Сначала установка пакета loki в devDep, потом npx loki init --config <путь до конфига storybook>
В package.json добавится конфигурация loki
Скрины будут сниматься на ноуте в хроме и iphone на хроме (судя по конфигам)
Меняем там в target с docker на app (Если работа в linux или macOS)
На винде могут быть проблемы с запуском (если так, то нужно вернуть target docker и запустить приложение docker на ПК)
Мне так же пришлось поднять версию loki до 0.29.0, т.к. под капотом 0.28.0 использовала 16 версию react и были конфликты
Для работы с loki сначала нужно запустить storybook
Для скриншотного тестирования необходимо выполнить команду npx loki test
После успешного выполнения тестов появится папка .loki со скриншотами в виде png разных компонентов в разных состояниях
При изменении чего-то в компонентах и прогоне повторных тестов, часть тестов упадет, т.к. они будут сравниваться со старыми скриншотами
в папке difference. 
При наличии различий в difference можно запустить скрипт report, чтоб сгенерить новые файлы (json и html), и там более наглядно посмотреть различия.
Регрессионное тестирование - когда мы убеждаемся, что новый функционал не сломал старый.
Так же скриншотные тесты помогают определить, что в сторибуке что-то не так, т.к. они снимаются на основании сторибука.
Скриншоты отправляются в удаленный репозиторий.
Добавили скрипт test:ui для скриншотных тестов и test:ui:ok для одобрения скриншотов (т.е. когда loki отловил ожидаемые изменения,
изменения которые осознанно сделаны и мы их подтверждаем)
Скриншотные тесты используют разные движки (по скорости) - https://loki.js.org/configuration.html.
default - pixelmatch движок.

27. У нас стало появляться много скриптов (линтеры, сборка, разные виды тестирования, сборка сторибука).
Запускать это вручную становится неудобно. Хочется автоматизировать процесс запуска этих скриптов.
Будем использовать Github-actions для настройки CI/CD.

CI/CD переводится как непрерывная интеграция и непрерывное развертывание (доставка).
Это конвейер, который позволяет автоматизировать рутинные процессы
(сборка приложения, прогон тестов, прогон линтеров, проверка типизации (CI) / деплой, релиз (CD) и т.д.).

Сначала CI.
CI процессы обычно запускаются скриптами, описанными в package.json.
Нужна автоматизация чтобы:
- Не делегировать эту ответственность (ручной запуск скриптов) на разработчика и нивелировать человеческий фактор
- Не загружать разработчика лишней работой (т.к. она стоит дорого)
- Повышение надежности приложения в целом
Хотелось бы, чтобы при создании pull request (PR) и при последующих коммитах в ветку
автоматически запускались бы все эти процессы (сборка, тесты, линтеры и пр. проверки (CI), которые необходимы в нашем приложении)
и чтобы мы не могли вмерджить ветку в main до тех пор, пока мы не убедились, что все эти процессы отработали без ошибок.
И если хотябы 1 из таких проверок упала, то нам нужно запретить merge в основную (main) ветку, чтобы не сломать код.

Настройка:
Примеры для настройки можно брать из guthub, либо сделать запрос github actions frontend, chat-gpt и т.д.
Создали папку .github в корне приложения, а внутри неё папку workflows (рабочий процесс).
Далее нужно внутри этой папки создать файл с расширением .yml (название любое).
Скопируем пример кода для файла из https://docs.github.com/ru/actions/writing-workflows/quickstart
Далее отдельным коммитов нужно запушить yml файл в github (commit m: "add main pipeline github actions")
Потом заходим в github репозиторий / actions.
Там будет этот workflow, в который можно провалиться и посмотреть на процессы, описанные в yml файле.
В начале скрипты будут в виде echo (т.е. логи текстов, моки для проверки). 
Там могут быть любые сложные скрипты, например npm run build.
В файле main.yml поменяли name: linting, testing, building.
В начале укажем что все проверки будут запускаться на push в ветку master и при создании pull_request.
Далее нужно описать jobs. Удаляем старую.
Создадим новую с названием pipeline (можно называть как угодно).
В поле runs-on указывается ОС, в которой будет запускаться job.
Затем необходимо указать версию NodeJS, которая будет использоваться
Для работы с фронтом, нужно всегда устанавливать в первую очень NodeJS, чтобы код мог работать.
В steps указаны наши скрипты
Там (после стэпов по установке NodeJS) первым делом нужно установить node_modules.
Далее можно например запускать сборку
Потом сделаем запуск скрипта линтера для ts, потом линтер для css, потом все виды тестов, потом сборку storybook.
Далее пушим в репозиторий, наблюдаем как выполняются jobs. (появится желтая точка в репозитории, из неё перейти быстрее).
Bundle-analyser отключил, т.к. он не дает завершиться процессу сборки.
В документации loki есть описание интеграции unit тестов в CI pipeline (https://loki.js.org/continuous-integration.html).
В начале нужно сделать сборку storybook, потом на основании этой сборки (storybook-static) можно делать скриншоты.
Т.е. запускать его в CI pipeline не обязательно. Добавили сборку в gitignore.
И добавили скрипт test:ui:ci для loki, который будет запускаться после сборки storybook и снимать с неё скриншоты.
Не забываем добавить скрипты в yml файл

Далее когда CI закончен без ошибок, мы мерджим код в main ветку, затем идёт сборка приложения (если это требуется).
И дальнейшая публикация этой сборки на тестовое или прод окружение (CD).
Т.е. CI/CD касается как ежедневных процессов (для тестирования), так и еженедельных (смотря какой спринт, релиз на прод).
Так же можно отдельно ознакомиться с темой CI/CD тут https://www.youtube.com/watch?v=ANj7qUgzNq4

28. Тут особо нового ничего не делали, только улучшили UI Sidebar. Добавили размеры кнопке. Сторисы для них.
Был нюанс, после пуша в репозиторий упали unit тесты.
Следующие тесты не запустились, т.к. конфиг был настроен так, что jobs выполняются последовательно.
Если одна из них падает, то следующие не запускаются. Нужно в step добавить проверку if: always(), чтобы они запускались в любом случае.
Сделали это для всего, что может идти последовательно (билд, линтеры, тесты, кроме инсталяции пакетов в начале).
Так же был изменён компонент Sidebar, там добавились ссылки, но не адаптировали тесты.
Примерно такая же проблема решалась для сторибука, делался декоратор с роутером.
Сделали похожую штуку для jest (unit) тестов.
В папке shared/lib/tests создали файл componentRender/componentRender.ts.
ComponentRender - одна единственную функцию. Будем её везде для unit-тестов использовать.
Т.к. зачем 2 разные функции работающие отдельно. 
Если в случае с декораторами это ещё можно понять, то в случае рендера это избыточно.
Так же упали сткриншотные тесты. Когда компоненты будут нагружены, смотреть скриншоты будет тяжело.
Есть инструмент reg-cli для сравнения скриншотов. Добавили пакет в devDep.
Создали папку scripts. Там будут храниться все скрипты, которые связаны с приложением (генератор бандлов, генератор отчетов и т.п.).
Создали там файл generate-visual-json-report.js. Нужно понимать что он находится вне src, поэтому через babel не проходит.
Нужно писать js в чистом виде (require вместо import и т.п.). Так же могут быть не доступны некоторые веб апи.
Добавили скрипты в package.json.
test:ui:json - генерит файл .loki/report.json, но он не удобен для чтения.
test:ui:html - генерит html отчет (используя json) с интерфейсом, который удобен для чтения и сравнения скриншотов.
test:ui:report - объединяет эти 2 скрипта.
Можно каждый скриншот открыть и посмотреть наглядно, какие произошли изменения.
Так же нужно указать в .gitignore эти сгенеренные отчеты, т.к. там они не нужны.
Подтвердили скрины (test:ui:ok скриптом), чтобы прошли CI.

29. Модальные окна. Реализация через порталы.
Есть несколько способов для отображения/скрытия модалки. 
Первый это opacity: 0 и pointer-events: none (с возвратом на 1 и auto).
Второй это через z-index: -1 (с возвратом обратно).
С помощью transform: scale добавили плавную анимацию открытия модалки.
Для анимации закрытия пришлось писать js, т.к. одним css не справиться.
Так же добавили закрытие на кнопку Esc.
Есть linter правила для react хуков (https://legacy.reactjs.org/docs/hooks-rules.html#eslint-plugin) - есть в CRA по дефолту.
Поставили правило 'react-hooks/exhaustive-deps': 'error' для массивов зависимостей react хуков.
С ним будут подсказки, что в массиве зависимостей отсутствуют нужные зависимости либо присутствуют лишние.
Семантически правильно помещать компонент модального окна в самый верх. С этим поможет концепция порталов.
В shared слое создали Portal, который можно удобно переиспользовать.
Обернули им Modal, теперь модалка рядом с root папкой с react-app.
Но из-за этого не будут доступны глобальные стили и т.д., 
т.к. модалка находится вне приложения, а все завязано на App (там импорты и т.д.).
Перенесли импорт стилей в index.ts, а в глобальных стилях перенесли определения vars в body из .app класса.

30. Redux-toolkit. Если устанавливать redux-toolkit, то отдельно redux устанавливать не нужно.
Тулкит нужен для уменьшения бойлерплэйт кода (не нужно создавать экшены, экшен-криэйтэры...).
Внутри есть библа immerJs, которая позволяет изменять state.
Так же с коробки есть redux-thunk и инструменты разработчика, их не нужно ставить отдельно.
Чтоб редакс работал нужно все приложение обернуть в провайдер.
Создадим app/providers/StoreProvider(ui/config).
В конфиге будет конфигурация провайдера редакса (корневые редьюсеры, мидлвэры, вкл/откл тулзы и т.д.).
Для RouterProvider был вынесен конфиг в shared, т.к. роуты используются всеми уровнями компонентов.
Но для StoreProvider конфиг сделали рядом с ним в этой же папке.
Вынесли configureStore в createReduxStore, чтобы можно было переиспользовать (для Storybook, jest и т.п.).
Девтулзы включаем только в режиме разработки (из глобального флага).
Создали интерфейс StateSchema, в котором будет описание типов глобального состояния (передается в джинерике в конфигурацию стора).
Так же создали первую сущность в entities/Counter. В ней сегменты ui и model.
model будет отвечать за state, операции с этим state. ui - это непосредственно компонент.
В model будут папки slice (со слайсом редакса), selectors (с селекторами, которые достают данные) и types (типы данных).
Все типы стэйта будем называть с окончанием Schema (т.е. это часть схемы).
По методологии иногда типы могут импортироваться из вышестоящего слоя (например в models импорт из app).
createSelector из toolkit (под капотом reselect внутри тулкита) позволяет переиспользовать другие селекторы.
Он хорош тем, что, во-первых, не нужно дублировать код.
Во-вторых, мемоизирует значение (зависимость - данные, возвращаемые переданным селектором).
В-третьих, можно использовать несколько селекторов, комбинировать/объединять их и в одной функции получать одно значение.
тип DeepPartial из тулкита позволяет типизировать стейт с отдельным куском.
для каждого редьюса, слайса пишутся тесты. 
Если какое-то поле кто-то поменяет, то тест упадет, может предотвратиться баг.
Т.к. будем писать много тестов, то сделали сниппет (ts)

describe('$FILE$', () => {
    test('', () => {
        expect().toEqual();
    });
});

Добавили в componentRender обертку StoreProvider, чтоб мы смогли тестировать компоненты использующие стор.
Добавили в jest.config globals, для определения __IS_DEV__ глобальной переменной, т.к. jest этого не видет.
Не видит потому, что тестовая среда отличается от среды, которую настраивали в webpack. 
Поэтому глобальные переменные, настройки и т.п. надо делать отдельно.
При тестировании UI для Counter.test.tsx у меня возникла проблема с userEvent. Устарело апи.
Пришлось установить пакеты @testing-library/user-event и @testing-library/dom.
import userEvent from '@testing-library/user-event';
const user = userEvent.setup();
await user.click(screen.getByTestId('some-element'));

31. В этом модуле правки глобальных стилей для модалки.
Передали theme в classNames, как строку в массив additional, т.к. это глобальный селектор класса, то он будет доступен.
Изменили названия тем в енамке Theme (уникализировали), чтоб уменьшить вероятность ошибок (app_light_theme вместо light).
И в themes стилях напрямую обращаемся к селектору .app-dark-theme (а не .app.dark).
Пришлось очистить localStorage, чтоб обновить значение строки.
В хуке useTheme сделали document.body.className = newTheme вместе с сетом в состояние и localStorage.
Тогда они действительно станут глобальными стилями в body.

31.1. Имитация бекенда (JSON server).
Есть сервис jsonplaceholder, с помощью которого можно получать разные данные (https://jsonplaceholder.typicode.com/).
Он спроектирован на базе https://github.com/typicode/json-server, который можно быстро настроить и поднять.
Установили пакет json-server (глобально и локально как дев зависимость), 
добавили в корень папку с файлом json-server/db.json.
Проверить запуск сервера можно командой json-server --watch ./json-server/db.json --port 8000
Этот сервер можно гибко настраивать и поначалу в нём нет механизма авторизации, но её можно добавить.
Сделана имитация авторизации. Создали json-server/index.js.
С фронта будет отправляться захардкоженная строка, а сервер будет её проверять (подобие токена).
При разлогинивании на фронте, будет эта строка удаляться.
Создали скрипт "start:dev:server": "node ./json-server/index.js"
Работать будет так. Отправляется post запрос на /login с указанием username и password.
Если пользователь находится, то он возвращается с id. Этот id используется как ключ.
Пока что проверка авторизации только по наличию строки в заголовке запроса (Authorization), без проверки.

32. Создание кастомного инпута для авторизации. Создали entities/User. Там слайс model. 
Это всё что связано с пользователем (со стором, стэйтом, получение данных о пользователе, реализация редьюсеров...).
Создали первую feature - AuthByUsername. Называются как глаголы, фичи будут использовать слой ниже entities.
Архитектурно такая же файловая структура как и в других слоях, есть public api для максимальной изолированности слоёв,
то что не передаётся из public api изолировано и не используется все слоя.
ui, lib, model и т.д. К каждому слою относятся своя логика, не разбрасывается по всему проекту, а хранится рядом.
Создали в shared слое компонент input.
Сделали lazy пропс в модалке, для формы авторизации (и других компонентов, для которых необходим ленивый рендер модалки 
или в неё требуется поместить асинхронный компонент, который нужно подгружать тогда, когда подгружается модалка). 
Т.к. модалка монтируется в DOM дерево в самом начале, когда мы нажимаем на кнопку войти, фокус из инпута теряется.
Так же уменьшается размер бандла, пока такая модалка не открыта. Регулируется это поведение при помощи lazy в props модалки.

33. Husky. Это пакет, который предназначени для пре-коммит хуков гита. 
Т.е. на какое-то гит действие (git commit, git push) можно повесить какие-то проверки, аналогично тем, которые в github-actions. 
Инициализация npx husky-init
Появилась папка в корне проекта .husky. Для примера есть файл pre-commit, там можно запускать что угодно, 
но обычно запускают только линтеры (что-то легкое, что выполняется быстро).
Потому что запускать всё подряд (сторибук, тесты и т.д.) это очень долго
и на каждый коммит это делать неудобно. Но мы добавили все, т.к. github-actions бесплатно дает лимитированное число проверок.
Поэтому будем делать их тут на прекоммит. Но нужно запускать сторибук локально, 
т.к. в github-actions делалась сборка и на основании неё уже скриншотные тесты.

34. Авторизация. В фиче AuthByUsername
loginReducer сделали необязательным параметром, т.к. будет подгружаться асинхронно.
В папке services бизнес логи с asyncThunk. Там создадим первый loginByUsername вместе с файлом test.
Для запросов на сервер используем axios.
Ошибки обрабатываются в санках с thunkAPI.rejectWithValue. Вообще из thunkAPI можно получить dispatch, 
редьюсер для получения данных и стора и т.д.
Санки в extraReducers. Т.е. обычные reducers для обычного изменения состояния, а extraReducers для asyncThunk.
У каждого asyncThunk есть 3 состояния: 
pending (запрос еще идет), fullfilled (запрос выполнен успешно), rejected (запрос выполнен с ошибкой).
Можно их все обработать в extraReducers, через builder.addCase.
Для каждого case типы action.payload подтягиваются такие, как были указаны в санках (для error свой, для fulfilled свой).
Создали компонент Text в shared слое. Он предназначен для работы с текстовыми данными, для стандартизации.
Где-то будут заголовки, спаны, параграфы и т.п., и это надо одинаково отрисовывать.
В идеале разработать такую библиотеку компонентов, при которой css будут писаться по-минимуму. 
Т.е. все потребности должна удовлетворять библиотека.
В санке авторизации так же делаем сохранение в localStorage. В слайсе добавляем initAuthData, который будет брать данные
из localStorage и сетать их в стор. Сам метод initAuthData будем запускать в корне приложения.

Подведение итога:
У нас есть entity User, которая отвечает за то, авторизован пользователь или нет. 
Внутри себя она хранит данные об этом пользователе.
Для формы авторизации сделана отдельная фича, которая изолирует внутри себя данные формы, ошибки, индикацию загрузки.
Получилось так, что в фиче в publicApi наружу выдается только компонент модалки, тип и редьюсер.
Не используются какие-то внутренние штуки как селекторы, asyncThunk, экшены 
и не создаётся лишних связей (всзаимодействий) между модулями. К такому необходимо стремиться.
В фиче используется нижестоящий слой entity, так и нужно делать в FSD.

Чтоб фича была в сторибуке, нужно подключить провайдер редакса (shared/config/storybook/StoreDecorator);
Так же в конфиг для сборки сторибука нужно определить IS_DEV переменную
config.plugins.push(new DefinePlugin({ __IS_DEV__: true })); 
Всегда true, т.к. storybook используется только в режиме разработки. Кто-то использует и для прода, но тут не так.
Для i18n так же сделан декоратор TranslationDecorator
в config/storybook/preview.ts добавлен
Если скриншотные тесты ломаются, нужно запускать report и смотреть что там

35. Оптимизация бандла. Асинхронные редьюсеры.
Для оптимизации бандла для прод сборки, вынесли в buildPlugins.ts плагин BundleAnalyzerPlugin из условия isDev.
запустим yarn build:prod (появится ссылка в терминале)
В parsed режиме весит 304.84кб, в gzipped 94.26кб

Для начала сделали AsyncLoginForm (асинхронный компонент формы LoginForm), обернув в Suspence рендерим его в модалке.
При проверке в девтулзах (network) видно как подгружается дополнительный чанк при открытии модалки.
Бандл main уменьшился на 2кб

Разница не большая, т.к. компонент маленький. Плюс это прод сборка. Для дев сборки разница может быть уже в 20кб.
Так же есть ньюанс, что компонент асинхронный. Но редьюсер с экшенами - нет (т.к. они подключаются по итогу к корневому редьюсеру),
поэтому они уходят в главный бандл.
В редьюсерах, как правило, достаточно много строк кода и можно неплохо урезать главный бандл,
если подгружать его асинхронно.
100 строк кода примерно равно 3кб в прод-сборке
Можно загуглить "redux code splitting" и найти инфу как асинхронно подгружать редаксовский код.
Можно использовать store.injectReducer/replaceReducer.
Создали рядом файл reducerManager.ts (там будет логика для асинхронного добавления или удаления редьюсеров из стора).
Он используется в связке с асинхронными компонентами, чтобы код редьюсера так же не попадал в main чанк.
Подключили его store.reducerManager в store.ts. Убрали там LoginForm редьюсер (он будет асинхронно подгружаться).
Обязательно передать в поле reducer: reducerManager.reduce, чтоб передать новые редьюсеры
В LoginForm.tsx используем стор, const store = useStore(); через хук из redux
в useEffect при монтировании компонента store.reducerManager.add('loginForm', loginReducer);
Из экспорта модуля убрали экспорт наружу (т.е. он используется самим модулем и асинхронно подгрузится).
При размонтировании компонента нужно так же убрать его store.reducerManager.remove('loginForm');
Вынесли в отдельный компонент src/shared/lib/components/DynamicModuleLoader/DynamicModuleLoader.tsx
Им нужно будет оборачивать асинхронные (lazy) компоненты
логику по асинхронному добавлению редьюсера (не в shared/ui т.к. пол сути рендера разметки интерфейса нет).
Вернули BundleAnalyzer только в dev режиме.
Вообще есть отдельные библиотеки для Lazy подгрузки редьюсеров, но тут реализовано свое решение.

Падали скриншотные тесты, т.к. в сторибуке не отображаются ошибки неверных кредов для авторизации.
Т.к. при инициализации не определяется асинхронный редьюсер.
Добавили в StoreProvider передачу asyncReducers, которые передаются в createReduxStore.

36. Тестирование фичи authByUsername. TestAsyncThunk.
Написание простых тестов на селектоны, на слайс и actionCreator.

Сначала написали тесты на селекторы (getLoginUsername, getLoginPassword и т.д.).

Так же на asyncThunk loginByUsername. Там нужно мокать запросы (jest.mock('axios') и потом использовать модуль axios).
jest для замоканных модулей добавляет функции (например axios.post.mockReturnValue()), которые позволяют замокать какое-то
возвращаемое значение. Но TS по-умолчанию эти типы не подхватывает, поэтому можно воспользоваться конструкцией:
const mockedAxios = jest.mocked(axios, true).
1 аргумент это модуль, который хотим замокать. 
2 (true) - это флаг с глубоким моком (т.е. мокаем не только сам модуль, но и внутренние поля).
asyncThunk это actionCreator, который по итогу вызова возвращает action.
Как отрабатывают диспатчи в asyncThunk:
- 1 вызов диспатча отрабатывает когда вызван сам экшен loginByUsername
- 2 вызов диспатча - когда вызывается экшен setAuthData с передачей response.data отработанного запроса
- 3 вызов диспатча - когда происходит fullfilled, т.е. когда экшен успешно выполняется (после return в конце).
В случае ошибки диспатч вызовется 2 раза (т.к. не будет setAuthData).
Эта логика для тестирования asyncThunk будет переиспользоваться, чтобы не дублировать.
Вынесли её в shared/lib/tests/TestAsyncThunk/TestAsyncThunk.ts
Это класс, в котором будет изолирована эта логика.

Так же пишется тест для loginSlice.
Тестировать isLoading или error избыточно, т.к. обычно в слайсах тестируют присвоения (в actionCreator такие тесты уже написаны).

37. Страница профиля. useAppDispatch. Оптимизация ререндеров и мемоизация.
Хук useDispatch не возвращает все типы результата вызова диспатча.
Что бы это исправить можно загуглить https://redux-toolkit.js.org/usage/usage-with-typescript.
Создать тип (AppDispatch в store.ts) и хук useAppDispatch (в shared/lib/hooks).
Например подтянутся типы для result.meta.requestStatus, можно будет делать проверку по нему.
В LoginForm по результату useAppDispatch (fulfilled) сделали закрытие модалки в onLoginClick (запуск onClose модалки).
Далее расширили структуру данных в db.json для json-server.
Создали pages/ProfilePage. 
(Для lazy импортов нужно чтобы компонент экспортировался по-дефолту, поэтому не page компоненты так экспортятся).
Добавили конфиг в Sidebar, чтобы на основании него отрисовывались новые табы.
Для начала сделали SidebarItem, он будет принимать item. Тип этого item будет определяться в директории model.
Для иконок в svg файле удалялись fill, чтобы можно было управлять цветом извне.

Дебажили мемоизацию. Вынесли мапанный массив с разметкой в useMemo.
В девтулзах браузера открыли вкладку components (реактовский девтулз).
Нажали шестерёнку и выбрали галочку на "Highlight updates when components render."

Так будут подсвечиваться обновления (рендер компонента), в виде обводки элемента в UI.

Ререндер компонента в 3 случаях:
1) Изменилось состояние
2) Изменился props
3) Ререндер родителя (этот пункт можно предотвратить мемоизацией при помощи memo)

При оборачивании компонента memo, он будет сравнивать пропсы.
Если пропсы не изменились при ререндере родителя, то ререндер компонента не произойдёт.
ThemeSwitcher и LangSwitcher так же обернули в memo, чтобы они не ререндерились лишний раз.

Оборачивание в memo - хорошая привычка и почти 90% компонентов необходимо оборачивать в memo.
Пробежались по компонентам и обернули в memo (Sidebar, Navbar).

Какие компоненты оборачивать в memo не стоит:
1) Компоненты у которых есть children, т.к. в большинстве случаев children будет меняться 
и перерисовку компонента это не предотвратит (если конечно это не простая структура в виде строки и прочего примитива)/
Т.е. например Button (где children это строка) имеет смысл мемоизировать, а Modal (где children всегда компоненты) - нет.
2) Когда пропсы не мемоизированы (колбеки не в useCallback, сложные структуры данных типа объекта не в useMemo)

Когда перерисовывается интерфейс, задействуется процессор, видеокарта. А memo всего-лишь тратит какое-то количество памяти.
Сейчас памяти у всех оч много и забить какой-то процент браузера достаточно сложно, нужно хранить миллионы замемоизированных компонентов.
А вот вычислительные мощности (процессор, видеокарту) нужно по-хорошему беречь, чтобы все работало быстро.

Далее создали entities/Profile.

38. Инстанс API, ApiUrl, thunkAPI.extra.
Нужно создать настройку axios в обном месте, чтобы в разных местах не настраивать его одинакого, с одним и тем же доменом и т.п.
Создали shared/api/api.ts в котором создали инстанс axios.
$ перед названием переменной инстанса axios ставится, чтобы как-то его отличать.
Внутри thunk (например в loginByUsername.ts) нужно получить доступ до инстанса, который сделали.
Это можно делать обычным импортом/экспортом, но мы использовали другой способ.
Есть агрумент thunkAPI.extra, в которой можно положить любые вспомогательные функции, данные.
В thunkAPI.extra мы и поместили инстанс апи (в файле store.ts в конфигурации рутового стора указывается поле middleware).
В redux-toolkit уже есть по-дефолту набор мидлвар (thunk, с помощью которого можно удобно работать с изменениями стейта).
Когда поместим в extra инстанс апи, можно будет в санках делать запросы extra.api.post.
Так же указан в инстансе baseURL, и его можно в запросах уже не писать.
Так же можно navigate (из useNafigate from react-router-dom) поместить в extra.
Далее нужна настройка типизации extra, т.к. ts не подхватывает типы в инстансе санки.
Описание типов в app/providers/StoreProvider/config/StateSchema.ts.
Вынесли для инстанса апи baseUrl, (можно исходя из __IS_DEV__, но мы создали новую глобал переменную __API__).
Переменная __API__ будет задаваться на этапе сборки приложения (config/builds/).
Добавили apiUrl в типы BuildEnv и BuildOptions (чтобы можно было извне это поле задавать).
B при создании нового инстанса new webpack.DefinePlugin добавили __API__.
Примерно то же самое для сторибука (__API__: '', в config.plugins.push).
И в jest.config.ts определил глобально __API__: ''
Так же в app/types/global.d.ts declare const __API__: string;
И в eslintrc.js __API__: true, (Чтобы он не ругался).
Инициализация самого значения в webpack.config.ts (const apiUrl = env.apiUrl ?? 'http://localhost:8000').
Т.е. либо получаем это значение из переменной окружения, либо по-умолчанию локалхост.

39. Модуль профиля. Фетчинг данных. TS strict mode.
Продолжили реализацию модуля профиля. Сделаем servises (асинхронные экшены).
Сделали extraReducers в profileSlice с сохранением фетченных данных в стор.
Сделали селекторы, для чтения этих данных в компонентах.
(state: StateSchema) => state.profile.data.first. Тут есть момент, поле дата опциональное.
Но при попытке получить вложенное поле из data, ts не ругается, т.е. может получиться, что у undefined будет запрашиваться поле.
В таком случае приложение упадет с ошибкой. Это связано с тем, что не стоит StrictMode в typescript.
Включили strict mode и правили ошибки. В tsconfig.json поле "strict": true.
Использовать ts без строгого режима не имеет смысла. Нужно обязательно его использовать на проектах.
Чтобы такие вот ошибки не пропускать.
TS ошибки на рантайм не влияют, поэтому фронт не падает из-за них.
Так же добавили в entities/Profile/ui/ProfileCard, которую отрендерили в ProfilePage.

40. Починка типов и проекта после TS strict mode. ThunkConfig.
Интересные моменты:
ref может быть типа MutableRefObject (можно менять ref.current) и просто RefObject (only reading ref.current).
Сделали глобальный тип DeepPartial в global.d.ts.
Есть свойство "no-undef" в eslint. Это свойство предотвращает использование каких-то глобальных переменных, типов.
Отключили это правило, т.к. оно в основном используется с var, а мы его не используем.
После включения strict mode, он распространяется не только на файлы разработки, но и на конфиги.

41. Модуль профиля. Avatar. Редактирование и сохранение. Приватные роуты.
Сделали ProfileCard переиспользуемым, путем передачи данных в props, а не используя внутри селекторы.
Вообще слой entities редко когда обладает своим состоянием. 
Чаще всего это переиспользуемые компоненты, куски логики, запросы к серверу, типы и т.п.
Поэтому entities/Profile/ui/ProfileCard будет чисто визуальным, а логику вынесем в pages.
В профиле кнопку "Редактировать" поместили на уровне page.
Т.е. где-то на странице мы хотим редактировать, а не в карточке. По этому это функционал страницы.
Создали pages/ProfilePage/ui/ProfilePageHeader.
Далее реализовали функционал, чтобы редактировать данные в полях можно было только после нажатия на кнопку "редактировать".
За это будет отвечать поле readonly (добавили в props Input - readonly).
В слайсе сделали помимо data свойство form, чтоб там сохранять вводимые данные и отделить их от основных.
Реализовали санку сохранения данных на сервере. В ней впервые используем getState для получения данных для отправки.
На текущий момент getState() возвращала unknown (т.е. она не знала какого типа данные она будет возвращать).
Указывается тип в джинерике ThunkConfig.state (добавили в тип ThunkConfig state: StateSchema).
В компонентах для получения стэйта мы используем хук useSelector, а внутри asyncThunk мы используем getState.
Так же будет отправляться put запрос (т.к. на обновление данных). В json-server/db.json они тоже изменятся.
Создали shared/ui/Select.
Так же вынесли в entities/Currency сущность валюты. Она может быть в создании поста, в кошельке, в профиле пользователя.
Можно воспользоваться средствами переноса webstorm по переносу enum из 1 файла в другой, чтоб не править везде импорты.
Правой кнопкой по enum (refactor -> move). Там же в ui будет селектор чисто для currency (удобно переиспользовать).
То же самое для Country (в entities).
Так же, если разлогиниться, но в карточке профиля будет ошибка (т.к. контент доступен только авторизованным пользователям).
Для этого реализован PrivateRoute. Пока сделали по колхозному, в конфиг добавили поле authOnly, по условию которого рендер.

42. Валидация профиля. Коды ошибок.
Создали entities/profile/model/services/validateProfileData.
Можно сделать простую функцию, либо asyncThunk, которая берет данные из стейта.
Мы пойдем по 1 пути, когда функция принимает профиль как аргумент.
Создали enum типы валидационных ошибок (в том числе с ошибкой от сервера).
Применили проверку в санке updateProfileData, перед совершением запроса. Если ошибки есть, то rejectWithValue.
В ProfilePage получаем ошибки из селектора, мапим массив в компонентах Text.
В profileSlice сделали созранение/удаление validateErrors, где это нужно.
Добавили словарь с отображениями ошибок с переводом (по коду);

43. Глобальная переменная __PROJECT__. Тесты на модуль профиля.
Содали сторис для ProfileCard.
Для тестирования или отображения в стрибуке изображений, лучше использовать локальный asset, чтобы не грузить её с сервера.
Поместили такие картинки в shared/assets/tests.
В сторисах для profilePage в storeDecorator передали form данные.
Там была ошибка запроса (по-хорошему в сторибуке не должно быть спама запросами, нужно подтягивать моканные данные).
Есть разные способы предотвращения запросов в компонентах (в useEffect).
Мы использовали один из способов. Разделили среды, в которых исполняется код.
Для buildPlugins расширили входные аргументы, передали project: 'storybook' | 'frontend' | 'jest'.
Для всех трёх сред своя конфигурация. Аргумент project для каждой среды можно переопределить.
Сначала в webpack.config.ts передали в buildWebpackConfig аргумент project: 'frontend' (т.е. это основная среда, в которой ведётся разработка).
В файле buildPlugins определили новую глобальную переменную __PROJECT__: JSON.stringify(project).
То же самое сделали для тестовой среды jest.config.ts (в globals __PROJECT__: 'jest').
То же самое для конфига storybook в файле webpack.config.ts (__PROJECT__: JSON.stringify('storybook')).
Теперь определены 3 среды, в зависимости от которых можно реализовывать тот или иной функционал.
Так же в eslint.rc добавили __PROJECT__: true, чтобы линтер не ругался.
Так же в глобальную декларацию global.d.ts нужно так же добавить глобальную переменную __PROJECT__, чтоб не ругался ts.
При этом не просто string (declare const __PROJECT__: 'storybook' | 'frontend' | 'jest').
Если добавится еще одна среда, можно в типах просто добавить её в 2-х местах.
В ProfilePage в useEffect делается запрос dispatch(fetchProfileData()) только если __PROJECT__ !== 'storybook'.
После этого в сторибуке запрос не отправляется, данные подтягиваются моканные, прописанные в сторисах ProfileCard.

Далее писали юнит тесты на ProfileCard.
Для начала селекторы, потом сервисы.
В updateProfileData тестируется санка, в которую данные не передаются в виде аргумента, а они извлекаются из апи redux - getState.
Чтобы проинициализировать стэйт и функция getState внутри санки вернула данные,
в конструктор класса TestAsyncThunk сделали возможность передачи необязательного аргумента state.
this.getState = jest.fn(() => state as StateSchema);
В updateProfileData.test передадим initialState.
Потом написали тесты на profileSlice.
На реальных проектах редьюсеры редко покрываются тестами, только если там есть условия, циклы, какая-то сложная логика.
Мы написали чисто ради тренеровки.

44. Color pallete. Внедрение новой третьей темы.
Использовался ресурс https://mobilepalette.colorion.co/.
Там можно подобрать цвета таким образом, чтобы было 2 темы (основная и inverted).
Основной паттерн это: есть несколько цветов (основной и второстепенный для шрифтов, заднего фона).
С помощью него подобрали новую цветовую палитру.
Добавили файл orange.scss с новыми цветами.
импортировали этот файл в index.scss.
Изменили useTheme, добавили switch case для переключения тем.
Так можно технически добавлять неограниченное количество новых тем.

45. npm concurrently. File templates.
Небольшое упрощение разработки.
Фронт и dev-server запускались отдельно 2-мя командами (start и start:dev:server).
Нужно чтобы была команда, которая в дев режиме одновременно бы запускала сервер и фронт.
Для этого понадобился пакет concurrently.
Работает просто, concurrently и через пробел несколько команд, запускающих скрипт.

Так же, каждый раз приходится создавать папку. 
Потом нужно создавать одноименный компонент, одноименные модульные стили, тесты, сторисы и т.д.
В webstorm, settings => editor => file and code templates. Можно создать новый шаблон, к нему добавлять дочерние шаблоны.
Название файла определяется через переменную ${NAME} (в том числе в названии файла).
Для создания шаблона, правой кнопкой мыши по папке, new, <Название созданного template> (будет в списке опций).

46. React refresh plugin. build babel loader.
Не работал refresh plugin.
Для примера, в корневой div можно добавить инлайновый стиль (color: red),
но в режиме реального времени он не обновляется, а только при перезагрузки страницы.
Хотя подключался HotModuleReplacementPlugin (в файле buildPlugin),
и он должен обеспечивать своевременное обновление некоторых моментов (которые должны работать, например изменение стилей).
Взяли плагин отсюда https://github.com/pmmmwh/react-refresh-webpack-plugin.
В buildLoaders.ts для babel-loader добавили плагин в dev режиме.
В buildPlugins.ts в дев режиме добавили react-refresh-plugin.
Создали loaders/buildBabelLoader.ts, чтоб вынести бута плагины babel.
В результате, при изменении стилей на элементе, он обновляется в браузере сразу, без перезагрузки страницы.
Что-то он может обновлять, что-то нет. Но чаще всего быстрое обновление именно для верстки (стили, надписи).
Это немного ускоряет разработку.

47. Router v6 private protectеd routes. Защищенные маршруты.
Несколько уроков назад был реалирован роут, защищенный (только для авторизованного пользователя).
Если на него зайти, то тут 404 роут, это нарушает пользовательский опыт (ux).
Пользователю не всегда понятно, почему роут иногда доступен, а иногда 404.
По-хорошему для таких роутов надо делать редирект.
Создали компонент RequireAuth, который (как мидлвар) проверяет, если isAuth то рендерит children, иначе редирект на main.
Обернули этим компонентом роуты, по условию authOnly.
Так же был ньюанс, что AppRouter инициализировался раньше, чем мы получали данные о пользователе.
Получалось, что на момент когда 1 раз отрендерился AppRouter, мы еще не авторизованы.
Добавили в схему User флаг _inited, который показывает, что пользователь проинициализирован (в редьюсере initAuthData).
В корневом App.tsx отрисовываем Router только если _inited === true (т.е. данные о пользователе получены и мы точно знаем авторизован он или нет).

48. ArticlesPage и ArticleDetailsPage. Декомпозиция. Сущности. Webpack publicPath.
Создали 2 page (ArticlesPage - список, ArticleDetailsPage - одна статья).
Роуты /articles и /articles/:id. (Множественное число для еденичной сущности лучше масштабируется и следует правилам rest).
При переходе на роут /articles/123 была проблема, что браузер пытается запросить чанк,
т.е. в строке запроса появляется лишний articles (должен запросить из корня, а запрашивает из articles, а у нас такой папки нет).
Т.е. такие статические файлы по факту запрашиваются из папки build, в которую мы делаем сборку. 
Просто в dev режиме эта папка не создается, эти файлы все хранятся в памяти (описания в buildWebpackConfig.ts в поле output).
Нужно добавить publicPath в output

## Пояснение от себя (что нагуглил):
При переходе на роут /articles/123, браузер интерпретирует путь /articles как базовую директорию для запросов к статическим файлам.
Поэтому, вместо того чтобы запросить файл main.a20f058c4f8f5bf80443.js из корня (/main.a20f058c4f8f5bf80443.js),
он делает запрос по неправильному пути: /articles/main.a20f058c4f8f5bf80443.js.
Это происходит из-за особенностей работы браузера с относительными путями к статическим ресурсам, 
когда путь для запросов определяется текущим маршрутом.

В режиме разработки (dev-сервер Webpack):
Статические файлы не хранятся на диске. Они предоставляются из памяти (in-memory) dev-сервера.
Dev-сервер настроен так, чтобы корректно обрабатывать любые запросы и возвращать соответствующие файлы,
даже если путь содержит дополнительные сегменты (например, /articles/123).

В режиме production (после сборки):
Статические файлы сохраняются в папке build, и сервер должен их предоставлять из этой папки.
Сервер обычно обслуживает файлы строго в соответствии с указанным путём,
поэтому запросы по неверным путям (например, /articles/main.a20f058c4f8f5bf80443.js) приводят к ошибке 404.

49. Entity article, async thunk, slices. Блоки. Skeleton loader.
Расширили данные в json-server/db.js
Реализация статей будет примерно как на habr. Картинки, блоки с текстами, блоки с кодом, темы статьи.
Создали новую ентити Article.
В entities/articleDetails не будет делать отдельную папку для каждого селектора, все делается в одном файле.
Т.к. как правило селекторы максимально простые.
Внедрили Skeleton для нотификации разгрузки в шаблонах контента.
В интернете полно гайдов как сверстать скелетон (css), поэтому время на него не тратили.

50. Страница статьи. Блочная структура. Компонент Code. Копирование.
Тут делали отображение самой статья, её составных блоков.
Добавили size enum для Text.
Добавили компонент обертку в shared/ui/Icon, который задает для всех иконок в приложении цвет (fill), исходя из темы.
Добавили компонент shared/ui/Code (компонент отвечающий за стилизацию текста в виде кода).
В html5 есть специальный тег code для работы с кодом, но нужно обернуть в pre,
который позволяет сохранить все пробелы, переносы и т.п., чтоб текст выглядел как код.


