Webpack Bundle Analyzer - пакет для анализа бандла вебпака
Нужно добавить плагин BundleAnalyzerPlugin в конфиг
После этого, при запуске приложения, во второй вкладке ана порту :8888 откроется страница с описаниями пакетов,
которые используются в приложении.
Если запускать сборки run build:dev run build:prod, то так же будет открываться страница с пакетами билдов
Слева сверху можно посмотреть вес чанков в разных режимах.

Для jest нужно установить пресет для парсинга tsx - @babel/preset-typescript и @babel/preset-react.
В babel конфиге изменили ["@babel/preset-react", {"runtime": "automatic"}]

Так же нужна настройка CSS модулей для сторибука (по-дефолту был импорт в конфиге, но не адаптирован под мой конфиг)
В config/build/buildLoaders.ts есть cssLoader. Решили вынести лоадеры в отдельную папку config/build/loaders
Вынесли туда в файл buildCssLoader.ts

Для уменьшения размера бандла некоторые вещи нужно подгружать асинхронно, например используя lazy import для pages.
Сделали lazy пропс в модалке, для формы авторизации (и других компонентов, для которых необходим ленивый рендер модалки
или в неё требуется поместить асинхронный компонент, который нужно подгружать тогда, когда подгружается модалка).
Так же уменьшается размер бандла, пока такая модалка не открыта. Регулируется это поведение при помощи lazy в props модалки.

Для оптимизации бандла для прод сборки, вынесли в buildPlugins.ts плагин BundleAnalyzerPlugin из условия isDev.
запустим yarn build:prod (появится ссылка в терминале)
В parsed режиме весит 304.84кб, в gzipped 94.26кб

Для начала сделали AsyncLoginForm (асинхронный компонент формы LoginForm), обернув в Suspence рендерим его в модалке.
При проверке в девтулзах (network) видно как подгружается дополнительный чанк при открытии модалки.
Бандл main уменьшился на 2кб

Так же для ArticleRating сделали lazy импорт, т.к. компонент не является важным, он находится внизу страницы.
И такие компоненты желательно подгружать асинхронно.
Т.к. подгружать в main чанк их особо смысла нет, т.к. отрисовываются снизу и их не видно в момент инициализации (возможно пользователь и не будет скролиться).
Suspence оборачивается уже в файле async с lazy компонентом.

Разница не большая, т.к. компонент маленький. Плюс это прод сборка. Для дев сборки разница может быть уже в 20кб.
Так же есть ньюанс, что компонент асинхронный. Но редьюсер с экшенами - нет (т.к. они подключаются по итогу к корневому редьюсеру),
поэтому они уходят в главный бандл.
В редьюсерах, как правило, достаточно много строк кода и можно неплохо урезать главный бандл,
если подгружать его асинхронно.
100 строк кода примерно равно 3кб в прод-сборке
Можно загуглить "redux code splitting" и найти инфу как асинхронно подгружать редаксовский код.
Можно использовать store.injectReducer/replaceReducer.

Вынесли в отдельный компонент src/shared/lib/components/DynamicModuleLoader/DynamicModuleLoader.tsx
Им нужно будет оборачивать асинхронные (lazy) компоненты/
Вернули BundleAnalyzer только в dev режиме.
Вообще есть отдельные библиотеки для Lazy подгрузки редьюсеров, но тут реализовано свое решение.

Вынесли для инстанса апи baseUrl, (можно исходя из __IS_DEV__, но мы создали новую глобал переменную __API__).
Переменная __API__ будет задаваться на этапе сборки приложения (config/builds/).
Добавили apiUrl в типы BuildEnv и BuildOptions (чтобы можно было извне это поле задавать).
B при создании нового инстанса new webpack.DefinePlugin добавили __API__.
Примерно то же самое для сторибука (__API__: '', в config.plugins.push).
И в jest.config.ts определил глобально __API__: ''
Так же в app/types/global.d.ts declare const __API__: string;
И в eslintrc.js __API__: true, (Чтобы он не ругался).
Инициализация самого значения в webpack.config.ts (const apiUrl = env.apiUrl ?? 'http://localhost:8000').
Т.е. либо получаем это значение из переменной окружения, либо по-умолчанию локалхост.

Для buildPlugins расширили входные аргументы, передали project: 'storybook' | 'frontend' | 'jest'.
Для всех трёх сред своя конфигурация. Аргумент project для каждой среды можно переопределить.
В webpack.config.ts передали в buildWebpackConfig аргумент project: 'frontend' (т.е. это основная среда, в которой ведётся разработка).
В файле buildPlugins определили новую глобальную переменную __PROJECT__: JSON.stringify(project).
То же самое сделали для тестовой среды jest.config.ts (в globals __PROJECT__: 'jest').
То же самое для конфига storybook в файле webpack.config.ts (__PROJECT__: JSON.stringify('storybook')).
Если добавится еще одна среда, можно в типах просто добавить её в 2-х местах.

Не работал refresh plugin.
Для примера, в корневой div можно добавить инлайновый стиль (color: red),
но в режиме реального времени он не обновляется, а только при перезагрузки страницы.
Хотя подключался HotModuleReplacementPlugin (в файле buildPlugin),
и он должен обеспечивать своевременное обновление некоторых моментов (которые должны работать, например изменение стилей).
Взяли плагин отсюда https://github.com/pmmmwh/react-refresh-webpack-plugin.
В buildLoaders.ts для babel-loader добавили плагин в dev режиме.
В buildPlugins.ts в дев режиме добавили react-refresh-plugin.
Создали loaders/buildBabelLoader.ts, чтоб вынести бута плагины babel.
В результате, при изменении стилей на элементе, он обновляется в браузере сразу, без перезагрузки страницы.
Что-то он может обновлять, что-то нет. Но чаще всего быстрое обновление именно для верстки (стили, надписи).
Это немного ускоряет разработку.

При переходе на роут /articles/123 была проблема, что браузер пытается запросить чанк,
т.е. в строке запроса появляется лишний articles (должен запросить из корня, а запрашивает из articles, а у нас такой папки нет).
Т.е. такие статические файлы по факту запрашиваются из папки build, в которую мы делаем сборку.
Просто в dev режиме эта папка не создается, эти файлы все хранятся в памяти (описания в buildWebpackConfig.ts в поле output).
Нужно добавить publicPath в output.

При переходе на роут /articles/123, браузер интерпретирует путь /articles как базовую директорию для запросов к статическим файлам.
Поэтому, вместо того чтобы запросить файл main.a20f058c4f8f5bf80443.js из корня (/main.a20f058c4f8f5bf80443.js),
он делает запрос по неправильному пути: /articles/main.a20f058c4f8f5bf80443.js.
Это происходит из-за особенностей работы браузера с относительными путями к статическим ресурсам,
когда путь для запросов определяется текущим маршрутом.

В режиме разработки (dev-сервер Webpack):
Статические файлы не хранятся на диске. Они предоставляются из памяти (in-memory) dev-сервера.
Dev-сервер настроен так, чтобы корректно обрабатывать любые запросы и возвращать соответствующие файлы,
даже если путь содержит дополнительные сегменты (например, /articles/123).

В режиме production (после сборки):
Статические файлы сохраняются в папке build, и сервер должен их предоставлять из этой папки.
Сервер обычно обслуживает файлы строго в соответствии с указанным путём,
поэтому запросы по неверным путям (например, /articles/main.a20f058c4f8f5bf80443.js) приводят к ошибке 404.

Если сделать yarn build:prod, потом открыть файл со сборкой (build), то там есть js, html, css файлы, но нет json с переводами.
Файлы хранятся в public и нужно что-то сделать чтобы в билде они оказались.
Для этого возпользовались плагином CopyWebpackPlugin (установили copy-webpack-plugin в dev-deps).
В файле config/build/types/config.ts в интерфейс BuildPaths добавили поле locales (путь до файлов с переводами).
И также buildLocales (путь куда переводы необходимо перемещать).
В webpack.config.ts указываем в paths оба поля.
Мы этот путь указывали в src/shared/config/i18n/i18n.ts в поле loadPath.
В config/build/buildPlugins.ts добавляем new CopyPlugin.
После этого, если сделать снова сборку прод, то в build появятся папки с json файлами переводов.

Сборка долгая (ts loader, babel loader), из-за этого долгая, потом уменьшим в 2 раза.
webpack умеет делать tree-shaking кода и избавляться от неиспользуемых импортов в сборке.

В проекте на элементах есть атрибут data-testid и он нужен только для RTL тестов.
После сборки видно, что в DOM-нодах этот атрибут остаётся.
Причем он есть как в dev, так и в prod бандлах.
Каждый символ весит какое-то количество байт и от этих id бандл немного прибавляет в весе.
Написали свой babel плагин, который выпиливает эти атрибуты из сборки.

В целом у нас долгая сборка в dev режиме.
Это из-за того, что у нас работает и babel loader, и ts loader и в рантайме в том же процессе проверяются типы.
Это все достаточно ресурсоёмко, поэтому откажемся от ts loader и будем использовать проверку типом в отдельном процессе.
В tsconfig нужно включить опцию isolatedModules.
При его включении будет ошибка на экспортах типов "Re-exporting a type when the --isolatedModules flag is provided requires using export type".
Так же с этой опцией ts следит, чтобы не было пустых ts файлов.
Если в кратце, то ts компилируется в js, и иногда за эту компиляцию отвечают другие инструменты, типа babel.
И они не всегда понимают полную картину типов, кода. И вот эти вот типы (types, interfaces), их иногда, чтобы упростить сборку,
нужно выносить в изолированные модули (это файлы, в которых находятся только интерфейсы и типы).
И когда мы делаем экспорты или импорты, мы явно указываем type.
Например export type { ArticlesPageSchema } from ...
Тем самым создаётся изолированность модуля.
Это с точки зрения кода хорошо, и с точки зрения перформанса тоже (немного ускоряет сборку).

Установим вебпаковский плагин circular-dependency-plugin (с типами).
Есть и другие мощные инструменты, например DependencyCruizer.
Он помимо кольцевых зависимостей так же умеет следить за "мёртвым" кодом и т.п.
Если в кратце кольцевые зависимости, это когда модуль А использует зависимости модуля Б, а модуль Б использует модуль А.
Чтобы это пофиксить, по-хорошему надо создать модуль С, вынести в него то, что используется в 2-х других модулях и переиспользовать.
Нужно от этого избавляться, т.к. сборщик не всегда этот клубок может распутать.
По итогу может стрелять ошибка или утечка памяти.
В buildPlugins заюзали плагин.

До миграции на babel loader время начальной сборки составило 8700ms (ребилд с изменённым кодом 2000ms).
Почему так происходит.
Помимо ts-loader есть babel-loader, который тоже обрабатывает код, добавляет пресеты, плагины.
Там нужно отказаться от ts-loader в пользу babel-loader.
Если просто закомментировать ts-loader в файле buildLoaders.ts, то проект не запустится.
Нужно настроить babel-loader, чтоб он мог выполнять задачи ts-loader.
В buildBabelLoader передали isTsx, чтобы мы могли отдельно работать с tsx файлами, и отдельно с обычными ts файлами (их обрабатывать прийдется немного по-другому).
Такое условие обработки test: isTsx ? /\.(jsx|tsx)$/ : /\.(js|ts)$/.

Понадобились @babel/plugin-transform-runtime и @babel/plugin-transform-typescript (для правильной работы с typescript).
В файле buildLoader разделили на 2 buildBabelLoader (1 для ts, другой для tsx).
После этого время начальной сборки составило 4700ms (ребилд с изменённым кодом 372ms).
Это произошло из-за того, что мы избавились от одного обработчика файлов (ts-loader).
Babel-loader в рантайме не умеет проверять типы (среда разработки подсказывает об ошибках, но сам сборщик запускает проект без ошибок).

Можно вынести эту проверку в отдельный процесс и этот процесс никак не будет замедлять сборку.
Для этого нужно установить fork-ts-checker-webpack-plugin
Его можно использовать вместе с ts-loader, либо с babel-loader (как у нас).
Примеры реализации: https://github.com/TypeStrong/fork-ts-checker-webpack-plugin/tree/main/examples
Вставили плагин в buildPlugins файл. После этого проект будет собираться,
но отдельным процессом сборщик будет проверять и выбрасывать ошибку типов, если такая имеется.
В процессе (в терминале) будет нотификация type checking in progress...
В итоге, теперь за компиляцию typescript в js отвечает babel-loader, от ts-loader мы отказались, а проверку типов вынесли в отдельный процесс.

Далее нужно реализовать выпиливание атрибута data-testid из prod-сборки, т.к. он нужен только на этапе тестирования (локально или dev).
Создали config/babel/babelRemovePropsConfig.ts (самописный плагин для babel).
Для понимания как они создаются можно загуглить babel plugin development. https://babeljs.io/docs/plugins#plugin-development
Похоже на создание плагина для линтера, так же работа с нодами в AST дереве
Identifier это нода AST дерева.
Полезно пользоваться ast-explorer когда пишем свои линтеры, плагины, при глобальном рефакторинге и внесении изменений.
Можно парсить код в ноды и потом с ними взаимодействовать.
Укажем глобально ноду Program, для того, чтобы мы могли в плагин прокидывать пропсы.
Прокидывать будем атрибуты, которые хотим выпилить из prod-сборки.
JSXIdentifier - нода для поиска JSX узлов,
но можно и просто Identifier если хотим работать просто с js файлами (так пишутся полифилы, для преобразования кода для старых браузеров и babel).
path.traverse - метод для прохода по всем нодам проекта.
После yarn build:prod можно в main бандле по поиску проверить наличие data-testid.
В buildBabelLoader добавили babelRemovePropsPlugin (по условию isTsx, т.к. просто для ts файлов нет смысла проверять, лишний процесс).
После повторной prod сборки будет только 1 атрибут data-testid (что-то внутри реакта).

Установили пакет react-device-detect, который распознает устройство пользователя по user-agent.
Есть другие, которые распознают по размеру экрана например
Для просмотра информации о бандлах пакетов (minified) можно использовать сайт https://bundlephobia.com/
Контент декларативно помещается внутрь BrowserView и MobileView, а либа сама определяет что показывать в зависимости от устройства.
Можно даже сделать 2 разных App для BrowserView и MobileView, и переиспользовать компоненты в lazy режиме.
И важно понимать, что когда мы находимся в desktop, то компонент для мобилки не подгрузится (и наоборот).
Поэтому при ручном тестировании нужно обновлять страницу после смены типа девайса.

Как только делается импорт данных из внешних библиотек, они подтягиваются в бандл.
Webpack за счет tree-shaking не включает в бандл либы, если импортируемые данные не используются.
Научимся лениво подгружать библиотеки только там, где они нужны, отдельными чанками, чтобы в main бандл они не попадали.
Логика по ленивой подгрузке будет в AnimationProvider.
Там через динамические импорты import() будут параллельно подгружаться библиотеки в Promise.all и сохраняться в ref.current.
Далее возвращаться из контекста. Для переиспользования нужно будет нужный участок кода оборачивать в провайдер с отображением нотификации загрузки.

## Aliases
Можно добавлять алиасы ('@/features/feature'), т.к. иногда возникают кейсы с пересечениями названий (например каких-то библиотек).
В buildResolvers.ts добавить в alias '@': options.paths.src
В tsconfig.json в path сделать ключ "@*".
После попытки запуска приложение будет много ошибок импорта. Делали скрипт для автоподставления алиасов в импорт (updateImports.ts).
После добавления алиасов сломался не только сторибук, но и линтер/jest/eslint-plugins.
В принципе ресолвинг модулей штука достаточно серьёзная и она охватывает не мало моментов и ньюансов. И нужно все это учитывать.

## Полифилы
Как babel, webpack понимают для каких браузеров компилируется код?
Где нужно добавлять полифилы? Как делать что бы на всех браузерах код работал?
Есть технология BrowserList. Описывается конфиг (.browserslistrc), в конфиге указываются версии браузера, которые мы хотим поддерживать.
И babel смотрит на этот конфиг и добавляет полифилы, в зависимости от того, насколько старые браузеры нам необходимо поддерживать.
Можно указать опции в конфиге (not dead, > 2% (процент пользователей, которые используют браузер), конкретные версии).
Обычно собираются метрики, смотрится кто пользователи, на чем сидят. И в зависимости от этого потом заполняется конфиг.
Опция defaults обычно покрывает большинство кейсов.
Поддерживать Internet Explorer смысла нет.
После настройки конфига бандл может стать весить меньше, т.к. babel перестал добавлять лишние полифилы для старых браузеров, кода становится чуть меньше.
Конфиг можно оч гибко настраивать, что можно даже для определённых стран указать определённые версии браузеров.
Например, условно говоря, в Китае пользователи используют один браузер, в России другой, в Америке 3-й и т.п.

## Улучшаем сборку. Babel loader cache. Postinstall hooks.
Из config/build/loaders/buildBabelLoader.ts выпилили плагин i18next-extract, т.к. не пользовались им (оказался багнутым, либо неправильно настроен).
Плагин babelRemovePropsPlugin испольщовался и в дев и в прод сборках (а нужно только в прод), добавили соответствующее условие.
Так сборка дев будет быстрее, т.к. чем больше плагинов, тем больше нагружается сборщик и медленнее она происходит.
Добавили exclude node_modules в cssLoader (по хорошему их везде надо исключать, чтоб не было случайных обработок такой большой папки).
Так же в cssLoader был MiniCssExtractPlugin, который есть так же и в config/build/buildPlugins.ts (в дев режиме и в прод).
Сделали его пуш только для прод сборки в buildPlugins, т.к. использовать его без лоадера смысла не имеет.
CopyPlugin тоже нужен только для прод сборки, чтоб переместить переводы из папки public в папку build.
Так же можно чучуть ускорить сборку, в файле .browserslistrc для прод все браузеры, а для дев только 2 последних версии определенных браузеров.
Тем самым babel прийдется меньше работать, т.к. под старые браузеры код оптимизировать не надо.

Так же сборку сильно нагружают карты исходного кода (source-map).
В файле config/build/buildWebpackConfig.ts для devtool указали eval-cheap-module-source-map как это рекомендуется в доке (быстрее ребилд, для дев режима, для прода медленно).
У лоадеров (у нас babel-loader, основной инструмент сборки, на который идет нагрузка) обычно есть кэши.
Там сохраняются какие-то куски кода, которые редко меняются. При ребилде лоудеру не нужно заного их билдить, он берет из файлов кэша.
В buildBabelLoader добавили cacheDirectory: true.
Например, в директории node_modules тоже есть папка .cache, при запуске сервера там появится папка babel-loader.
Особенно заметен прирост если большая кодовая база (будет формироваться много кэша). На маленьком проекте разница будет не ощутима.

Post-install хуки. Кэши периодически нужно очищать, особенно когда устанавливаем новые библиотеки.
Добавили скрипт postinstall, который будет выполняться после любой установки зависимостей.
Мы указали там удаление директории .cache в node_modules.
Для линукса или мака можно написать rm -rf для рекурсивного удаления, на винде скорее всего не отработает.
Скрипты должны быть универсальны ибо это антипаттерн (т.к. разрабы работают на разных устройствах).
Создали scripts/clear-cache.js. Там с помощью стандартных средств nodejs (path, filesystem) удалили эту папку на postinstall.

## SVGR. Обработка размеров и цветов иконки на этапе сборки.
В иконках svg есть местами fill. Плюс размеры задаются не совсем корректно.
Чтоб во всех местах не менять, мы используем SVGR loader.
Будут размеры и цвета из иконок выпиливаться и ими можно гибко управлять через css или пропсы компонента.
Сделали изменения в config/build/buildLoaders.ts, добавили плагины с настройками.
Иконки некоторые стали меньше, т.к. по дефолту размер 1em.
