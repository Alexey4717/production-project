## Концепция Feature flags. Постепенное внедрение новых фичей.
Компоненты фичей рендерятся по условию фиче флага. Сами фиче флаги хранятся в БД, чтобы их можно было в любой момент переключать.
Причём хранятся они для каждого пользователя отдельно.
Сделаем такие фиче флаги в нашей БД, внутри пользователей в поле features (isArticleRatingEnabled, isCounterEnabled).
Создали shared/types/featureFlags (в shared т.к. везде могут понадобиться).
Так же создали shared/lib/features
Мы сделаем фиче флаги не реактивными. Т.е. в стейт сохранять не будем. при смене сессии сохраняются куда-то в константу.
Если фиче флаги поменяются интерфейс перерисовываться не будет (т.к. реакт не подписывается на это, не реактивно).
У НАС ФИЧИ НЕ МЕНЯЮТСЯ В ХОДЕ СЕССИИ, ИХ НЕОБЯЗАТЕЛЬНО ДЕЛАТЬ РЕАКТИВНЫМИ!
Сама константа фиче флагов без экспорта. Снаружи доступа к ней не имеем. Чтоб случайно её не изменить.
Если хотим прочитать какой-то флаг, то будем использовать геттер.
Для изменения будем использовать сеттер (явно менять).
Добавили в интерфейс user фиче флаги.
В экшенах setAuthData и initAuthData вызываем сеттер фиче флагов.
В компонентах сделали условный рендеринг.
Есть и минус, если фиче флаги куда-то в глубь прорастают, типа в экшены, сеелкторы, хелперы. Усложняется система.
Дальше будем эту проблему решать.

## Унификация работы с флагами. Автоудаление старых фич.
Фиче флаги можно использовать не только как условие отображения фичей, но и как обновление UI.
Например есть старый компонент и новый компонент (редизайн).
Хочется сделать новый, не удаляя при этом старый, чтоб экспериментально его зарелизить и посмотреть как он зайдет для пользователей.
По условию отрисовывается новый или старый компонент.
В какой-то момент когда все тесты прошли, он старого кода избавляемся и оставляем только новый.
По итогу при выпиливании старой фичи может потребоваться много времени на определение, куда эта фича ещё проросла (функции, компоненты).
Кодовая база будет обрастать фичами, не будет желания их выпиливать.
Нужно придумать функционал, благодаря которому мы сможем автоматизировать и унифицировать работу с фиче флагами.
реализуем функцию toggleFeatures, которая будет принимать название фичи, старый и новый функционал.
Так функционал не прорастает в код и для переключения нужно будет использовать функцию toggleFeatures.
По итогу можно написать скрипт, который можно вызывать, передавать название фичи.
Этот скрипт будет обходить весь проект, находить использование функции toggleFeatures и удалять лишний код (т.е. оставлять только новый код).
Либо оставлять только старый (если эксперимент не удался).
Тем самым мы запрещаем разработчикам руками использовать фиче флаги, чтобы они прорастали в код, чтобы про было выпиливать.
Плюс мы еще настраиваем автоматику.
Создали shared/lib/features/toggleFeatures.
Реализовали скрипт scripts/remove-feature.ts для удаления фиче флагов с оставлением нужного функционала.

Для понимания как работать с AST можно скопировать туда код компонента целиком и смотреть как называются ноды и какие у них методы или поля.
В transform можно выбрать typescript.

В текущей реализации есть правила использования. Нужно передавать именно стрелочную функцию в on или off, объявленную в другом месте.
Можно написать линтер, чтоб запрещал внутри тела функции объявлять переменные и т.п., чтоб в одну строку передавалась функция, объявленная в другом месте.
Пример использования в src/pages/ArticleDetailsPage/ui/ArticleDetailsPage.

## Json Settings. Настройки пользователя. Localstorage на максималках.
Тема сохраняется в localStorage браузера.
Хотелось ты подобную общую информацию аккаунта сохранять, чтоб в разных браузерах отображалось одинаково.
По возможности надо просить бэкендеров сделать jsonSettings (хаотичные настройки, привязанные к аккаунту, которые определяет фронт).
У нас там будет theme, isFirstVisit, settingsPageHasBeenOpen.
У таких настроек нет жесткой схемы, там можно хранить рахные данные и постоянно менять/расширять их.
Например, тема, язык, разрешение на получение уведомлений/пушей, первый визит, проверять какие-то страницы, были ли открыты или нет,
видел ли пользователь новый блок, чтоб показать ему всплывающую подсказку.
Т.е. второстепенные настройки, которые можно сохранять с фронта на бэк, при этом бэк даже не знает, что там сохраняется.
Создали под это схему src/entities/User/model/types/jsonSettings.ts
Создали селектор получения данных из стор.
Изменили useTheme, чтоб определялась тема извне.
В toggleTheme передаем колбек saveAction, в котором уже будет во вне определяться где сохранять (localStorage, сервер, indexedDB и т.д.).

## ToggleFeatures. Обвязка для работы с компонентами. Автоудаление.
Реализуем компонент shared/lib/features/ToggleFeatures для рендера компонентов по фиче флагу,
а функцию toggleFeatures оставим для функций/хелперов.
Так будет семантически правильнее и удобнее работать.
Преимущество в том, что мы работаем с компонентами так же, как если бы мы работали, если б toggleFeatures и не было.
Так же поработаем со скриптом, чтобы он умел обрабатывать jsx. И добавили его в package.json

Добавили новый фиче флаг isAppRedesigned.
У всех пользователей он будет выключен, а у админа включен. Т.е. только админ будет видеть в начале обновление дизайна.
Одновременно будет и старый и новый дизайн.
Используем ToggleFeatures в разных компонентах для рендера нужной версии по фиче флагу.
Можно при желании создавать рядом компоненты, типа SidebarDepricated, SidebarRedisigned.

## Переключение нового и старого дизайна. Страница настроек. Обновление фичей.
Сделали фичу (uiDesignSwitcher) и страницу (SettingsPage),
в которой будет переключение фиче флага редизайна, без необходимости перехода с одной страницы на другую.
По-хорошему использовать там надо чекбокс, но его у нас нет, мы сделали через ListBox.
Отрефакторили раздел shared/lib/features.
Сделали запрос на изменение фичи.
Там после выполнения мутации window.reload, т.к. значение не реактивное.
Это норм практика, т.к. фиче флаги почти никогда не меняются в течение жизни сессии.

## ForceUpdateProvider костыль. Обновляем интерфейс.
Есть проблема, что после смены пользователя не меняется тип дизайна.
Т.к. фиче флаги не реактивные, часть интерфейса перерисовывается, а часть нет (в зависимости от того как устроены компоненты и как они отрисовываются).
Не хочется помещать фиче флаги в контекст или редакс, т.к. теряется возможность из использования в функциях, хелперах (вне компонентов и хуков).
И при этом в течение сессии как правило они не меняются.
Лучше использовать нереактивные данные и перезагружать страницу.
Так же есть костыль с forceUpdate.
Создали shared/lib/render/forceUpdate.tsx
Так в реальных проектах делать не рекомендуется, т.к. это костыль. Просто показана такая возможность.
C начала отрисовывается null, а потом через какой-то интервал (тик) интерфейс.
И при ререндере обновляются значения (в том числе по фиче флагам).
У этого есть проблемы с мемоизированными компонентами. Но в целом это работает и в редких случаях это можно применить, но нужно быть аккуратным.

## Поддерживаем feature flags в сторибуке.
Создали новый декоратор в сторибуке для работы с фиче флагами shared/config/storybook/FeaturesFlagsDecorator
Пример работы в src/entities/Comment/ui/CommentCard/CommentCard.stories.tsx
В config/storybook/preview.ts добавили addDecorator(FeaturesFlagsDecorator({})); чтобы фиче флаг сбрасывался для каждого сториса.
Потом если надо, можно эти значения переопределять в сторисах.
Так же пример использования в src/entities/Profile/ui/ProfileCard/ProfileCard.stories.tsx
Во всех видах тестов, когда добавляются новые инструменты, которые влияют на процессы (например фиче флаги),
это нужно где-то сразу документировать (TODO нужно добавить в реадми про декораторы), чтоб было видно что поддержан сторибук и т.д.
