В tsconfig добавили "include": ["./config/jest/setupTests.ts"],
после этого TS подхватывает все методы при написании кода в рантайме.

В tsconfig.json поле "strict": true.
Использовать ts без строгого режима не имеет смысла. Нужно обязательно его использовать на проектах.
Чтобы такие вот ошибки не пропускать.
TS ошибки на рантайм не влияют, поэтому фронт не падает из-за них.

Сделали глобальный тип DeepPartial в global.d.ts.

Есть свойство "no-undef" в eslint. Это свойство предотвращает использование каких-то глобальных переменных, типов.
Отключили это правило, т.к. оно в основном используется с var, а мы его не используем.
После включения strict mode, он распространяется не только на файлы разработки, но и на конфиги.

Указывается тип в джинерике ThunkConfig.state (добавили в тип ThunkConfig state: StateSchema) для типизации стэйта getState() при использовании в санке.

Сделали кастомный тип OptionalRecord в global.d.ts (т.к. в обычном Record все ключи обязательные должны быть, а в кастомном нет).

Чтобы отливливать ошибки присвоения редьюсеров по названию (например в StoreDecorator в defaultAsyncReducers), обновили тип более строго
export type ReducersList = {
[name in StateSchemaKey]?: Reducer<NonNullable<StateSchema[name]>>;
}

В целом у нас долгая сборка в dev режиме.
Это из-за того, что у нас работает и babel loader, и ts loader и в рантайме в том же процессе проверяются типы.
Это все достаточно ресурсоёмко, поэтому откажемся от ts loader и будем использовать проверку типом в отдельном процессе.
В tsconfig нужно включить опцию isolatedModules.
При его включении будет ошибка на экспортах типов "Re-exporting a type when the --isolatedModules flag is provided requires using export type".
Так же с этой опцией ts следит, чтобы не было пустых ts файлов.
Если в кратце, то ts компилируется в js, и иногда за эту компиляцию отвечают другие инструменты, типа babel.
И они не всегда понимают полную картину типов, кода. И вот эти вот типы (types, interfaces), их иногда, чтобы упростить сборку,
нужно выносить в изолированные модули (это файлы, в которых находятся только интерфейсы и типы).
И когда мы делаем экспорты или импорты, мы явно указываем type.
Например export type { ArticlesPageSchema } from ...
Тем самым создаётся изолированность модуля.
Это с точки зрения кода хорошо, и с точки зрения перформанса тоже (немного ускоряет сборку).
