Redux-toolkit. Если устанавливать redux-toolkit, то отдельно redux устанавливать не нужно.
Тулкит нужен для уменьшения бойлерплэйт кода (не нужно создавать экшены, экшен-криэйтэры...).
Внутри есть библа immerJs, которая позволяет изменять state.
Так же с коробки есть redux-thunk и инструменты разработчика, их не нужно ставить отдельно.
Чтоб редакс работал нужно все приложение обернуть в провайдер.
Создадим app/providers/StoreProvider(ui/config).
В конфиге будет конфигурация провайдера редакса (корневые редьюсеры, мидлвэры, вкл/откл тулзы и т.д.).
Для StoreProvider конфиг сделали рядом с ним в этой же папке.
Девтулзы включаем только в режиме разработки (из глобального флага).
Создали интерфейс StateSchema, в котором будет описание типов глобального состояния (передается в джинерике в конфигурацию стора).
Все типы стэйта будем называть с окончанием Schema (т.е. это часть схемы).

В FSD сегмент model внутри уровней будет отвечать за state, операции с этим state.
В model будут папки slice (со слайсом редакса), selectors (с селекторами, которые достают данные) и types (типы данных).
По методологии иногда типы могут импортироваться из вышестоящего слоя (например в models импорт из app). TODO сделать объявление в global.d.ts.

createSelector из toolkit (под капотом reselect внутри тулкита) позволяет переиспользовать другие селекторы.
Он хорош тем, что, во-первых, не нужно дублировать код.
Во-вторых, мемоизирует значение (зависимость - данные, возвращаемые переданным селектором).
В-третьих, можно использовать несколько селекторов, комбинировать/объединять их и в одной функции получать одно значение.
тип DeepPartial из тулкита позволяет типизировать стейт с отдельным куском.
для каждого редьюса, слайса пишутся тесты.
Если какое-то поле кто-то поменяет, то тест упадет, может предотвратиться баг.

Ошибки обрабатываются в санках с thunkAPI.rejectWithValue. Вообще из thunkAPI можно получить dispatch,
редьюсер для получения данных и стора и т.д.
Санки в extraReducers. Т.е. обычные reducers для обычного изменения состояния, а extraReducers для asyncThunk.
У каждого asyncThunk есть 3 состояния:
pending (запрос еще идет), fullfilled (запрос выполнен успешно), rejected (запрос выполнен с ошибкой).
Можно их все обработать в extraReducers, через builder.addCase.
Для каждого case типы action.payload подтягиваются такие, как были указаны в санках (для error свой, для fulfilled свой).

Так же есть ньюанс, что даже если использовать данные стора в асинхронных компонентах.
То редьюсер с экшенами не будут асинхронно подгружаться (т.к. они подключаются по итогу к корневому редьюсеру),
поэтому они уходят в главный бандл.
В редьюсерах, как правило, достаточно много строк кода и можно неплохо урезать главный бандл,
если подгружать его асинхронно.
100 строк кода примерно равно 3кб в прод-сборке
Можно загуглить "redux code splitting" и найти инфу как асинхронно подгружать редаксовский код.
Можно использовать store.injectReducer/replaceReducer.
Создали рядом файл reducerManager.ts (там будет логика для асинхронного добавления или удаления редьюсеров из стора).
Он используется в связке с асинхронными компонентами, чтобы код редьюсера так же не попадал в main чанк.
Подключили его store.reducerManager в store.ts. Убрали там LoginForm редьюсер (он будет асинхронно подгружаться).
Обязательно передать в поле reducer: reducerManager.reduce, чтоб передать новые редьюсеры.

Вынесли логику по lazy подгрузке в отдельный компонент shared/lib/components/DynamicModuleLoader/DynamicModuleLoader.tsx
в useEffect при монтировании компонента store.reducerManager.add(reducerName, reducer);
Из экспорта модуля убрали экспорт наружу (т.е. он используется самим модулем и асинхронно подгрузится).
При размонтировании компонента нужно так же убрать его store.reducerManager.remove(reducerName);
Им нужно будет оборачивать асинхронные (lazy) компоненты
логику по асинхронному добавлению редьюсера (не в shared/ui т.к. пол сути рендера разметки интерфейса нет).
Вообще есть отдельные библиотеки для Lazy подгрузки редьюсеров, но тут реализовано свое решение.
Так же была проблема что несколько раз глобально монтируется редьюсер (глоабльно это ни на что не влияет, но не очень хорошо).
В DynamicModuleLoader в useEffect где происходит монрирование редьюсеров нужно проверять, вмонтирован он уже или еще нет.
В ReducerManager добавили еще одно поле mountedReducers: Record<StateSchemaKey, boolean>.
Если значение true, значит редьюсер с данным ключем уже монтирован, иначе нет (или был удален).

Падали скриншотные тесты, т.к. в сторибуке не отображаются ошибки неверных кредов для авторизации.
Т.к. при инициализации не определяется асинхронный редьюсер.
Добавили в StoreProvider передачу asyncReducers, которые передаются в createReduxStore.

Хук useDispatch не возвращает все типы результата вызова диспатча.
Что бы это исправить можно загуглить https://redux-toolkit.js.org/usage/usage-with-typescript.
Создать тип (AppDispatch в store.ts) и хук useAppDispatch (в shared/lib/hooks).
Например подтянутся типы для result.meta.requestStatus, можно будет делать проверку по нему.

Внутри thunk (например в loginByUsername.ts) нужно получить доступ до инстанса апи (axios).
Это можно делать обычным импортом/экспортом, но мы использовали другой способ.
Есть агрумент thunkAPI.extra, в которой можно положить любые вспомогательные функции, данные.
В thunkAPI.extra мы и поместили инстанс апи (в файле store.ts в конфигурации рутового стора указывается поле middleware).
В redux-toolkit уже есть по-дефолту набор мидлвар (thunk, с помощью которого можно удобно работать с изменениями стейта).
Когда поместим в extra инстанс апи, можно будет в санках делать запросы extra.api.post.
Так же указан в инстансе baseURL, и его можно в запросах уже не писать.
Так же можно navigate (из useNafigate from react-router-dom) поместить в extra.
Далее нужна настройка типизации extra, т.к. ts не подхватывает типы в инстансе санки.
Описание типов в app/providers/StoreProvider/config/StateSchema.ts.

В компонентах для получения стэйта мы используем хук useSelector, а внутри asyncThunk мы используем getState.
Указывается тип в джинерике ThunkConfig.state (добавили в тип ThunkConfig state: StateSchema) для типизации стэйта getState().

Применили проверку в санке updateProfileData, перед совершением запроса. Если ошибки есть, то rejectWithValue.

Нормализация данных - концепция (redux-toolkit entity adapter).
Проблематика: пример с 4 списками товаров (все, измененные, черновик, на модерации).
При изменении состояния одной сущности из списка "все", она улетает в "измененные" и т.д.
Это та же сушность по сути. Дублировать её для всех для нескольких списков это избыточно,
плюс необходимо, чтобы все эти дублируемые данные были одинаковыми (реально частая проблема, которая возникает на практике).
Другой пример, у нас есть массив объектов и нам надо изменить одно из полей объекта.
Чтобы это сделать, нужно проитерироваться по всему массиву, найти нужный объект, заменить у него поле, а во всех остальных случаях возвращается старый объект.
Здесь приходит на помощь нормализация. Тут нужно относитья к данным на клиенте примерно так же, как к данным, хранящимся в БД на сервере.
При нормализации у объектов не хранятся вложенные объекты, хранятся только идентификаторы (foreign_key как в БД).
Так мы избавляемся от дублирования данных и плюс, при изменении в одном месте, изменения произойдут везде, где используется ссылка-id.
Так же данные хранятся не в массиве, а в объекте, где ключ это id. Уменьшается константное время допуска к объекту.
В redux-tooklit есть обстракция, с помощью которой можно делать нормализацию с минимумом строк кода.
С помощью createEntityAdapter, создается адаптер, с помощью которого реализуется большое количество функционала.
Он генерит набор базовых экшенов (CRUD-functions), предназначенных для работы с коллекциями, Набор базовых селекторов.
Данные достаем как useSelector(getArticleComments.selectAll). Так же есть другие полезные методы.
Теперь нет необходимости писать руками селекторы.
Но для кастомных, типа isLoading и error нужно писать селекторы.
В extraReducers в fulfilled можно использовать Adapter.setAll(state, action.payload);
Этот метод адаптера сам нормализует список (сформирует ids, entities и т.п.).
Для подгрузки на скролл используется addMany (чтобы полностью не перезатирался весь массив сущностей, а новые добавлялись в конец).

Решили формировать массив ссылок для сайдбара в селекторе редакса, подставлять там id текущего пользователя.
Воспользовались createSelector из редакса, чтобы переиспользовать селектор и создать на основе него другой для сайдбара.

При переходах на страницы зачищается история redux-devtools.
Это из-за того, что происходил новый рендер компонента StoreProvider, а в нем происходит новая инициализация стора.
Ререндер происходил из-за передачи функции navigate (из react-router).

Чтобы отливливать ошибки присвоения редьюсеров по названию (например в StoreDecorator в defaultAsyncReducers), обновили тип более строго
export type ReducersList = {
    [name in StateSchemaKey]?: Reducer<NonNullable<StateSchema[name]>>;
}

RTK-Query генерирует хуки для апи (в зависимости от названия эндпоинта),
которые запускаются в теле функционального компонента (похож на хуки graphql).
В них содержится генерируемая логика, типа индикация загрузки, error при запросе, refetch и т.п.
Если запускать хук с одним и тем же запросом в нескольких местах, то запрос технически будет отправляться один,
т.к. данные сохраняются в хранилище. Rtk-query сам кеширует и своевременно обновляет данные.
В хуках так же есть longPulling, чтобы с интервалом отправлять запросы.

Так же на проекте используется rtk-query, который надо так же адаптировать под storybook.
Есть Addon decorator для сторибука (storybook mock api).
Установили пакет storybook-addon-mock в devDeps (он для 6 версии или выше сторибука).
https://storybook.js.org/addons/storybook-addon-mock
В конфиге сторибука передать api в DefinePlugin.
Пример использования в сторисах ArticleRecommendationsList.stories.tsx.

Для сторисов если есть мок rtk-query запросов обязательно нужно добавлять StoreDecorator, т.к. это апи redux, и withMock декоратор.

Раньше всегда для rtk-query использовали хуки для запросов.
В rtk-query есть возможность выполнения запроса и без хуков (метод initiate()).
С помощью него можно отправлять запрос не только в компонентах.
В санке используем, с методом unwrap() для разворачивания промиса (чтоб reject тоже обрабатывался в санке).

## BuildSlice. BuildSelector. Улучшаем работу со state. useActions.
Основная работа со стейтом происходит через диспатчи и селекторы.
И не очень удобно постоянно диспатчить экшены, получать данные через селекторы.
Нужен механизм, с помощью которого можно будет напрямую получать данные без useSelector и напрямую диспатчить экшены без dispatch.
Будем напрямую биндить диспатч и селектор к данным.
Создали src/shared/lib/store/buildSlice.ts и buildSelector.ts
На примере Counter использовали.
const [useCounterValue, getCounterValue] = buildSelector((state) => state.counter.value)
Сам селектор (getCounterValue) можно использовать например в asyncThunk, а useCounterValue уже напрямую в компонентах (вместо useSelector(getCounterValue)).
Т.е. с помощью хука buildSelector биндится селектор и мы избавляемся от нужны постоянно использовать useSelector с компонентом (меньше кода).
В buildSlice обертка (вместо createSlice), которая внутри себя будет добавлять нужный нам функционал.
Джинерик взяли из createSlice (можно провалиться в либу).
@reduxjs/toolkit/dist - папка куда билдится редакс, можно оттуда брать типы
Из buildSlice вернется хук useActions, внутри которого все экшены будут сразу оборачиваться в dispatch и их можно было переиспользовать без диспатча.
Action-creators биндятся через bindActionCreators к диспатчу (мемоизируются, чтоб ссылки не менялись).
Добавили @ts-ignore, т.к. возвращаемый результат не соотносится с typeof slice.actions.
В counterSlice.ts сбилдили своим хуком слайс, извлекли из него useCounterActions
Использовали так: const { increment, decrement } = useCounterActions(). Не нужно использовать диспатч, это удобно, меньше бойлерплейт-кода.
Нужно улучшить buildSelector, чтобы в него можно было передать аргумент.
Добавили передачу args в хук и типизации.
Можно не использовать useSelector со сложными колбеками внутри.
