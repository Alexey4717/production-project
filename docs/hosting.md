Облачный сервер. SSH. Git. Удаленный сервер.
Сейчас есть деплой на netlify, он простой и никакого опыта не даст.
Сделаем деплой на свой облачный сервер с SSH, Nginx. Чтоб было базовое понимание.
Используем selectel.ru
После создания сервера у него будет ip-адрес, по которому он доступен.
Работа с сервером через ssh ключ. Возможно сначала установить ssh клиент.
Для подключения к серверу, в powershell вводим команду ssh root@<ip-address-server>
Вводим пароль, который в админке selectel.
После этого подключены к серверу удаленно, в этом же терминале. Там доступна вся ОС.
В начале лучше сделать sudo apt update (чтоб могли устанавливать правильные версии пакетов).
В первую очередь нужно установить node (лучше nvm) и git (sudo apt install git-all).
Нужно будет клонировать свой проект на сервере. Но он должен быть публичным.
Для приватного нужно будет сгенерировать ssh ключ внутри ubuntu сервера для работы с git-репозиторием.
После генерации заливаем публичный ключ на гитхаб в настройках аккаунта (deploy keys).
После этого можно клонировать проект.
Устанавливаем ноду той версии, которую использовали в разработке (у них 17.4.0, у меня 20.11.1).
При необходимости установить другие пакеты (например yarn).
Потом устанавливаем зависимости проекта.
Потом пробуем стартовать yarn start:dev.
Если запустится, копируем ip-адрес и вставляем в браузер с нужным портом (8000 - сервер, 3000 - фронт).
Сейчас он раздаётся как дев сервер, не минимизированный и не сжатый, но работает.

Nginx. Конфигурация. Взаимодействие с сервером.
     Nginx — это высокопроизводительный веб-сервер (для веб-сайтов с высокой посещаемостью) и проксирования.
     Научимся запускать nginx, раздавать статику, сбилженные файлы проекта.
     Для установки команда sudo apt install nginx.
     В папке <root>/etc появится папка nginx. В ней будет вся конфигурация.
     vim default - переход в файл конфига.
     Можно удалить все коменты, чтоб было проще читать.
     listen 80; - прослушиваем 80 порт.
     root - папка, в которой находится статика (html).
     location - по каким адресам доступно (у нас по всем после слеша, если что-то не найдено, будет присылаться 404).
     Для проверки, что всё доступно команда nginx -t, должно быть написано syntax is ok.
     Можно перезапустить nginx командой sudo service nginx restart
     чтобы гарантировано конфигурация была актуальная.
     В ОС, в папке будет /var/www/html будет index.nginx-debian.html
     Нужно создать папку, указанную в конфиге (у них production_project).
     Переходим в неё. Внутри создаём папку html.
     Возвращаемся в проект, запускаем сборку yarn build:prod, то там мы передавали переменные окружения для vercel.
     Передадим туда вместо этого ip адрес сервера, типа такого:
     webpack --env mode=production apiUrl=https://00.00.000.000:8000
     После сборки будет папка build со сборкой. Её нужно переместить в var/www/production-project/html
     командой mv root/production-project/build/ var/www/production-project/
     Там будет html файл и build папка, которую надо переименовать в html
     В папке html должна быть сбилженная статика (css, js, html файл)
     Можно перейти на ip-адрес (без портов), будет доступна прод сборка.
     Но бекенд еще не будет запущен. В папке проекта запускаем только сервер yarn start:dev:server
     Будет бэк и фронт работать по одному адресу, но на разных портах.
     После запуска можно пробовать логиниться.
     Еще есть ньюанс, если перейти на вложенный роут (например /about) и перезагрузить страницу, то вернется 404.
     Поскольку это SPA и index.html файл всего один.
     Нужно чтобы все запросы отправлялись именно в этот единственный index.html файл.
     А роутинг будет за счет react-router.
     Нужно поправить конфиг nginx.
     Переходим cd etc/nginx/sites-enabled/
     Там vim default (открываем конфиг).
     там вместо 404 ошибки вписать /index.html; (будет редирект).
     сохраняем - esc : v q
     Перезапускаем nginx.

nginx gzip. Сжимаем файлы. Подключаем домен. pm2 для сервера.
     Подключаемся к серверу, заходим в папку nginx.
     vim nginx.conf - редактирование главного конфига nginx.
     В нем есть настройка, которая подключает все файлы, находящиеся в папке sites_enabled.
     Есть настройки, связанные с gzip, для сжатия файлов.
     Если на сервере перезагрузить страницу со сбросом кеша, то прод бандл будет весить 435 кб.
     6 уровень сжатия по дефолту, всего 9.
     Рекомендуется сильно не сжимать, иначе не получим выгоду, т.к. на сжатие уходит время (должна быть золотая середина, 5-6 уровень норм).
     В gzip types указываются типы файлов, которые будут сжиматься
     Если раскомментировать gzip настройки, сохранить конфиг и перезагрузить nginx, то main бандл уже будет весить 137 кб.

Далее нужно сделать доменное имя, чтобы не заходить на сайт по ip-адресу.
Есть сайт reg.ru - регистратор доменов (подобных сервисов полно, можно использовать любой, настройки +- одинаковые, только ui отличается).
Нужно там зарегаться, потом перейти на "Зарегистрировать домен" и ввести домен, который нужен (желательно более уникальный).
Выбрать домен верхнего уровня (ru, com и т.п.).
Покупаем (рублей 150 в год). Они обычно дешёвые.
Отключаем "хостинг на месяц", "SSL" (т.к.у нас свой ssh будет).
После покупки идём в личный кабинет. Находим домен, будет написано "домен не подключён к сайту".
Во вкладке DNS серверы нажимаем на кнопку "Изменить".
В "Ресурсные записи" добавляем ip адрес своего сервера, для привязки домена к нему.
Добавляем для одной @ (subdomen) записи и еще для www записи (чтоб был доступен при указании www.<домен>).
После этого необходимо настроить ДНС серверы.
В selectel (где покупали сервер) нужно добавить домен.
Открываем панель управления. Указываем и добавляем купленный на reg.ru домен (без http:// только домен и домен верхнего уровня типа site.ru).
После добавления необходимо делегировать домен (передать управление доменом на DNS-серверы selectel).
Переходим в доменный регистратор, выбираем настройку ДНС серверов, добавляем свой список (как в рекомендациях).
ns<1-4>.selectel.org. Подтверждаем и ждем успешного выполнения операции (может быть не быстро, до 24 часов).
Спустя какое-то время на reg.ru появится запись "Для управления ресурсными записями обратитесь к провайдеру, предоставившему вам эти ДНС".
Это те тамые "А" записи. Т.к. мы их изменили, но нужно их указать на стороне selectel.
Переходим на вкладку домена в selectel. Добавляем запись типа @ и ниже ip-адрес сервера (то же самое для www).
Т.е. добавляем 2 записи типа "А" (то же самое что делали на reg.ru, чтобы они были доступны по этому адресу).
Нужно подождать какое-то время, пока ДНС сервера проверятся. Спустя какое-то время, перейдя по домену, откроется приложение.
Т.е. ДНС сервер сопоставил ip-адрес с доменным именем и определил что нужно открыть наше приложение.

Далее нужно настроить pm2 (Process Manager) для запуска NodeJS json сервера,
чтобы он не отключался после закрытия терминала (работал 24 на 7).
Подключаемся к серверу, переходим в папку с проектом. Нужно глобально установить pm2 (npm install mp2 -g).
Он позволяет запускать процессы, убывать, поднимать, если они по какой-то причине умерли, держать их в фоновом режиме и т.д.
pm2.keymetrics.io - дока. Есть инфа на канале.
Для запуска команда - pm2 start <название файла js>.
Т.е. pm2 start /json-server/index.js
Пробуем авторизоваться, если запросы улетают успешно, значит сервер запущен.

SSL. Сертификат. Настраиваем https.
     То, что настраивали ранее, работает поверх http.
     При попытке перейти на https, то приложение не откроется, т.к. для него мы дополнительно ничего не настраивали.
     Для быстрого получения сертификата и настройки https можно использовать Let's Encrypt.
     Можно зайти на их сайт, почитать описания. Открываем ссылку на certbot.
     Нужно указать на чём запущен http сервер (у нас nginx, так же указать версию ОС - Ubuntu (она отображается в selectel в консоли, либо в конфигурации)).
     Далее можно следовать инструкции. Подключиться по SSH к серверу, установить snapd.
     Вероятно на ubuntu он уже предустановлен (проверка snap --version).
     sudo snap install core; sudo snap refresh core
     При необходимости нужно удалить существующий certbot (если раньше настраивали).
     устанавливаем бот sudo snap install --classic certbot
     Подготовка бота ... (идем по пунктам, все описывать не буду).
     После этого соглашаемся со всем что предлагается. Указываем рабочую почту, домен (site.ru).
     Может быть ошибка настройки server_name. Нужно перейти в директорию sites-enabled => vim default.
     Напротив server name указать название домена (site.ru www.site.ru).
     Сохраняем Esc :wq , проверяем синтаксис nginx -t
     sudo service nginx restart
     Вызываем команду с настройкой certbot еще раз.
     Вводим указанные server name
     Если он скажет что уже есть, то передаем e, чтоб он его расширил.
     После этого можно перейти на сайт под https и он должен открыться.
     При запросах будут ошибки, т.к. клиент находится на https, а запросы делается на сервер под http.
     С точки зрения безопасности так делать нельзя и браузер такой запрос блокирует.
     Нужно сделать некоторые изменения в nodejs json-server/index.js.
     Так же это можно обойти через проксирование самого nginx.
     Можно гуглить node js https.
     Внутри проекта в терминале openssl genrsa -out /json-server/key.pem (если под виндой, то вероятно нужно через git-bash).
     ... все описывать не буду, команды меняются в зависимости от версии node ...
     В файле index.js с сервером тоже правки. Импорт https, создание сервера https, передаем опции и наш сервер.
     Раньше на 8000 порту был сервак, сейчас можно указать 443 - дефолтный для https.
     Из скрипта build:prod нужно удалить переменную окружения apiUrl, чтоб можно было его извне передавать когда это необходимо.
     Отправляем изменения на гитхаб, чтобы подтянуть этот код на облачном сервере.
     На сервере переходим в папку проекта, спуливаем свежую версию из репозитория.
     pm2 list - видим что запушен старый процесс nodejs приложения.
     pm2 stop 0 (0 - это номер процесса слева в таблице) - останавливаем его.
     и заного его запускаем pm2 start /json-server/index.js
     Если попробуем перейти на сервер через ip:443 то ошибка подключения (не защищено), но главное, что сервер под https работает.
     Вероятно нужна какая-то доверенность (недействительный сертификат). Но это не важно, т.к. бэк фейковый главное настроить фронт на стабильную работу с https.
     Поменяем порт для httpServer на 8443, чтоб не было конфликта потом с фронтом с nginx.
     Снова заливаем на гитхаб, спуливаем на сервере, обновляем процесс в pm2.
     Снова делаем прод сборку фронта на сервере, в качестве apiUrl указать бэк который работает поверх https.
     yarn dev:prod apiUrl=https://00.00.000.000:8443
     После успешного выполнения сборки нужно переместить статику в папку, которая раздаётся nginx (/var/www/production-project).
     Старую удаляем и закидываем новую.
     rm -rf var/www/production-project/html/ - удаление
     mv ~/production-project/build/ /var/www/production-project/html - перемещение
     через ls проверяем наличие файлов и папок.
     После этого проверяем работу приложения, как проходят запросы авторизации. Должно норм отрабатывать.
     После отравки запроса возникнет проблема протухшего сертификата (пофиксим в след уроке).
     https на фронте начал работать за счет добавления настроек от certbot в конфиг nginx (vim default) (прослушивание 443 порта, указал сертификаты и т.п.).
     Можно получившийся конфиг (nginx cat) скопировать и добавить в проект в файл nginx.conf, чтоб лежал на гитхабе в исходниках и его можно было посмотреть (технически ни на что не влияет).

Проксирование запросов. Query params.
     Сейчас мы все адреса указываем на пряму (/login, /article/1) и получается, что какая-нибудь страница /login может совпасть с ендпоинтом /login на сервере.
     Хочется это явно отделить, плюс на самом nginx сделать проксирование таких запросов строго на бэкенд.
     Можно посмотреть шпоргалку https://www.dmosk.ru/miniinstruktions.php?mini=nginx-redirects#proxypass
     Проксирование похоже на редирект, только оно касается запросов. Это когда мы отправляем запрос на один адрес, он редиректится на другой и по итогу возвращается ответ.
     Т.е. это грубо говоря перенаправление запроса с одного на другой.
     Чтобы это проксирование реализовать нужно указать несколько настроек (location) в конфиг nginx.
     Идея в том, что все запросы, которые включают в себя /api, будут перенаправляться на бэкенд.
     В proxy_pass нужно указать ip:port куда запрос нужно перенаправить
     После изменения конфига nginx заново собираем сборку с указанием apiUrl=https://site.ru/api (в конце /api).
     Снова удаляем старую папку с билдом, переносим новую.
     При проверке приложения, если запрашивать фронтовые роуты, то будет переход по роутам, если /api/адрес, то запрос по эндпоинту с бэка.
     Это осуществляется за счёт проксирования на nginx.
     Так же если перейти по роуту /profile/1, то во вкладке network будет запрос на /api/profile/1
     (т.к. сам запрос в компоненте, но проксируется (304 код перенаправления) nginx и по итогу возвращает валидный ответ).
     После этого должна исчезнуть ошибка не безопасного соединения, которая была в прошлом уроке.
     Важно ещё не забыть про локальную разработку. Т.к. при локальной разработке мы используем фейковый json-server и должен запускаться и юзаться http сервер (без лишних сертификатов и заморочек).
     Просто рядом создается http сервер с другом портом (порты можно прокидывать через переменные окружения)
     При проксировании не было учета query параметров и они не отправлялись в запросах на облачном сервере.
     Нужно в конфиге nginx поправить регулярку ($1$is_args$args).

Скрипт для деплоя. getApiUrl.
     Нужно чтоб процесс деплоя был удобным.
     Чтоб при изменении кода и пуше в удалённый репозиторий на облачном репозитории эти изменения применились.
     Сейчас необходимо руками спуливать на сервере актуальный код, запускать билд прод сборки, удалять старую статику, переносить новую статику.
     Для автоматизации этих процессов есть 2 варианта. Либо собрать докер файл, который будет автоматически запускать внутри себя установку nginx и т.д.
     Либо можно сделать простой bash скрипт, который эти ручные действия будет делать автоматически.
     В докере тут очевидно нужды нет, т.к. это избыточно для простого проекта, в котором нужен ли nginx и статика.
     Поэтому сделаем bash скрипт.
     Создаем в корне папку .deploy/deploy.sh и .deploy/nginx.conf
     В deploy.sh пишутся все эти команды, которые писались в ubuntu на облачном сервере.
     т.е. переход в папку проекта, прод сборка, удаление старой статики, перенос новой статики в var/www/production-project/html
     После этого, при изменении кода и пуша его в репозиторий, на сервере достаточно спулить и запускать bash скрипт (предварительно дав доступ на выполнение chmod +x deploy.sh).
     Будут по очереди запускаться процессы и команды и через какое-то время проект обновится.
     Это самый простой вариант написания bash script который минимизирует кол-во ручных действий на сервере.
     С докером это было бы избыточно, т.к. простое приложение со статикой, даже нет SSR.
     Если бы мы собирали различные тестовые версии (беты) под разные окружения (тест, прод, релиз), то можно было бы сделать через докер.
     Для примера, что происходило бы в докере.
     Сначала создается докер на основании версии Node.
     Потом package.json копируется внутрь, устанавливаются зависимости, копируется все что необходимо, происходит сборка.
     Потом на основе nginx образа переносится конфиг в нужную папку, удаляется папка html... (по сути все те же самые действия, что мы делали, только они изолированы в рамках докер контейнера).
     Так же можно по SSH подключаться к удаленному облачному серверу в процессе github actions в yml файл для CI.
     В secrets сохраняются host, username, password, port и т.п. Указываем нужный скрипт и можно к серверу по SSH подключаться.
     И далее выполнять любые команды на сервере, например запустить наш bash скрипт на ребилд прод сборки.
     secrets можно указать в настройках репозитория (settings/secrets and variables)
