## е2е тестирование с Cypress.
Тесты на роутер.
На данный момент у нас есть тесты с jest, loki и react-testing-library.
Все их можно назвать unit тестами, они проверяют отдельно взятые компоненты, функции, вёрстку.
Настал момент написать e2e тесты, которые будут проверять работоспособность приложения целиком в браузере на реальных данных.
Это одни из самых важных тестов. Они отлавливают высокоуровневые ошибки, которые не способны отловить некоторые unit тесты.
Для их реализации будет использовать одно из самых популярных решений - Cypress (полноценный фреймворк для написания тестов).
Есть также web driver (более низкоуровневое решение).
После установки cypress сделали скрипт в package.json test:e2e.
При запуске скрипта откроется десктопное приложение. Выбираем e2e тесты.
В корне проекта появится папка cypress.
В ней есть конфигурация для e2e тестов.
Так же есть команды - набор функционала который мы можем зашить внутрь cypress.
Например, функционал логина, драг-энд-дропа и т.д. Можно создавать в любом количестве.
ts ругался на cypress. Создали для него отдельный конфиг cypress/tsconfig.json, добавили там расширение нашего дефолтного конфига.
Чтоб настройки для cypress были примерно одинаковыми с нашим проектом.
Главное в конфиге это поле types, благодаря нему будет работа с типами и они будут подсказываться.
Так же рекомендуется поставить плагин cypress support.
В запущенном процессе прям из ui в браузере можно развернуть тесты или посмотреть примеры реализации и его возможности.
Файлы с расширением .cy.js, в них тесты пишутся с похожей структурой как в jest
В браузере в cypress приложении нажимаем create new spec.
Нужно запустить приложение, чтоб через cypress его прогонять.
Так же в корне приложения создался конфиг cypress.config.ts, в котором можно задавать определённые настройки.
Добавили baseUrl - основной адрес сайта. Так же можно передавать ссылки на стен окружение, тестовые среды, стенды в рамках поднятия CI-CD.
Pre-prod стенды, которые гоняются на каких то данных приближенных на проде (или копия данных с прода).
После этого не нужен в тест кейсах в cy.visit указывать полный адрес, достаточно вложенный типа /.
При описании тестов на логин, не нужно логиниться через нажатие на логин и ввод данных в форму.
Это антипаттерн. Правильным подходом будет написать запрос на сервер, который вернет необходимые авторизационные данные.
Потому что авторизация нужна будет в 90% кейсах, которые хочется протестировать. И делать это через интерфейс долго и не безопасно.
Т.к. команд будет много, лучше это декомпозировать в отдельные файлы в commands.
Пользовательские данные (login, password) для тест кейса лучше хранить секьюрно, в секретнице, в переменных окружения, так чтобы в коде просто не лежали.
e2e тесты в 1 очередь должны проверять глобальную работоспособность приложения в связке с бэкендом (полная интеграция).
Всё что можно протестировать в изоляции на фронте, должно тестироваться с помощью jest, RTL или скриншотов.
Потому что e2e тесты дорогие, они гоняются в реальном браузере, занимают много времени.
Т.е. нужно отправлять запрос на авторизацию, каких-то других данных, их сохранение. Это может работать нестабильно и поддерживть такие тесты сложнее.
Т.е. unit тестов должно быть много, а e2e должны писаться только на интеграцию с бэкендом, только на критический функционал.
Например сохранение профиля, авторизация, удаление/создание каких-то данных. Не проверяется отдельная работа кнопок, модалок и т.п.
Проверяется конкретная интеграция с бэкендом.

e2e тесты. Запросы, авторизация. тесты на профиль, статью, комменты, оценку.
Тут писали е2е тесты на профиль и article list.
beforeEach отрабатывает перед каждым тест кейсом. afterEach - после каждого тест кейса.
Например, у нас в beforeEach происходит авторизация (чтоб для каждого тейст кейса её не делать).
А в afterEach сброс данных (в профиле) к дефолтным, т.к. при тестировании они мутируются в БД.
В declare нужно указывать команды, чтоб типизация подхватывалась (например в cy.login()). Вынесли её в commands/common.ts.
Так же добавили метод getByTestId для cy, добавили в глобал типы, так будет проще пользоваться поиском элементов, без большого бойлерплейт кода.
Все, что переиспользуется, выносится в отдельные команды и глобал типы.
Можно добавлять команды как Cypress.Commands.addAll и передавать туда весь модуль (со всеми именованными импортами).
Проверки делать внутри команд не нужно (там исключительно только какие-то действия, нажатие на кнопку, ввод в интуп и т.п.), они делаются внутри тест кейсов.
TODO нужно будет написать тест кейсы на поиск и сортировку статей.
Для тестов статьи вопрос, какую статью тестировать, т.к. они уникальны и могут меняться.
Сделали команду, которая позволяет создать статью перед тест кайсами и еще команду для удаления после всех промежуточных тестов, чтобы она не засоряла БД.
TODO добавить команду очистки комментария в БД (если json-server не удаляет комментарии при удалении связанной с ней статьи, надо сначала проверить).

Моки. Стабы. Фикстуры. Скип тестов. Интерцепторы на запросы и фикстуры.
Создадим тест, который будет падать, чтоб словить ошибку. Представим, что на бэке что-то изменили и не предупредили фронт.
Но при этом засоряются отчёты, мы не можем прогнать релизную регрессию, вмёрджить ПР из-за этого.
В таком случае, если долго и трудно разбираться, можно скипнуть тест-кейс как it.skip().
Потом уже в рамках техдолга в отдельной задачи можно его исправить или удалить.

Второстепенные запросы, которые напрямую не требуются для тесткейсов (например тестирование только возвращаемых данных, а не того, как запрос отправляется),
можно мокать, чтобы не перегружать сервер. Плюс такие моки будут отрабатывать быстрее и стабильнее (т.к. настоящий запрос может отвалиться с ошибкой).
Создали пару json файлов с фикстурными данными в папке cypress/fixtures.
Их будем читать и использовать как ответ от сервера.
Можно автоматизировать процесс создания фикстур и переиспользовать.
В тесткейсах фикстуры используются в такой конструкции cy.intercept('GET', '**/articles/*', { fixture: 'article-details.json' }).
Термин "Стаб" это синоним "мок" - фейковые подготовленные данные (для имитации запроса).
В ui от cypress при выполнении тесткейсов на замоканном запросе будет флаг "no alias", при наведении на который можно убедиться в том, что он замоканный.
Если тесткейсов не оч много (не более 100), то можно в ручном режиме добавлять в каждый кейс интерцепторы.
Можно разделять на 2 discribe тесты с моками и с реальными запросами.

В командах можно не только добавлять новые, но и перезаписывать существующие (Cypress.Commands.overwrite) - пример в commands.ts.
Должны быть так же библиотеки, которые делают это автоматизированно.

Когда делаем какую-то задачу, создаём ПР. Там прогоняются тэсты. Представим что команда большая (30-40 человек).
Для каждого ПР прогоняются 100-500 тест-кейсов и они начинают спамить на сервер много запросов (которые еще и не стабильны).
Это все может тупить, ломаться, флапать и всех это будет бесить, никто к тестам серьёзно относиться не будет.
Поэтому с запросами в dev режиме можем работать в рамках фикстур. Перед релизом уже прогоняются тесты один раз и там летят настоящие запросы (и сохраняют новые фикстуры).

Изолированные тесты на компоненты с Cypress.
В cypress есть возможность тестировать компоненты в изоляции.
Отличие от RTL в том, что cypress компонент рендерится в браузере и мы нажимаем на реальные кнопки, вводим в реальные поля.
А в RTL используется виртуальная среда (jest dom) и не всегда может поймать баг (т.к. поведение эмулируется).
Но опять же, в браузере тесты прогоняются дольще, они менее стабильные и поддерживать их сложнее более стабильные RTL.
RTL - это классические юнит тесты, а компонентные тестирования на cypress - интеграционные. В них нужно писать какой-то важный функционал.
В приложении cypress выбираем "Component testing", выбираем фреймворк (у нас webpack).
Будет создана папка cypress/component.
Так же компонент нужно обернуть в стор, сделали изменения в src/shared/lib/tests/componentRender.
Вынесли TestProvider для переиспользования в e2e.
Там так же добавили ThemeDecorator и импорт глобальных стилей из app,
чтоб в тестах в браузере компоненты выглядили как в приложении (для RTL они были не нужны, но если будут ничего страшного).

Если подытожить e2e тесты прогоняются в браузере с данными сервера (в таком виде как на проде). А компоненты - изолированные тесты число для них, но более приближенные к проду.
ТАк же можно в Cypress.Commands.overwrite определять обертку провайдеров.
