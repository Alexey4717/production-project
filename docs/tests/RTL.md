## React testing library
При тестировании UI для Counter.test.tsx у меня возникла проблема с userEvent. Устарело апи.
Пришлось установить пакеты @testing-library/user-event и @testing-library/dom.
import userEvent from '@testing-library/user-event';
const user = userEvent.setup();
await user.click(screen.getByTestId('some-element'));

Чтобы проинициализировать стэйт и функция getState внутри санки вернула данные,
в конструктор класса TestAsyncThunk сделали возможность передачи необязательного аргумента state.
this.getState = jest.fn(() => state as StateSchema);

HTML report для тестов.
Для UI тестов уже генерится. Для unit тестов нет (для них и сделали).
При запуске скрипта yarn test:unit не очень удобно просматривать ошибки и понимать что не так с тестами.
Загуглили jest html report. Можно делать свои репорты, но мы подключим готовый.
Подключим jest-html-reporters. После установки пакета, нужно добавить в jest.config reporters.
Изменили publicPath: '<rootDir>/reports/unit' (нужно добавить в git-ignore).
И добавили опцию inlineSource: true, чтоб все генерилось в одном js файле.
Можно туда же сохранять отчет по e2e тестам, локи.

Для тестирования компонентов, нужно навесить атрибуты data-testid на них (чтобы находить).
Предлагается называть такие идентификаторы как <Название компонента>.<Что конкретно тестируем>.

Некоторые компоненты могут асинхронно (лениво) подгружаться вместо с асинхронной подгрузкой редьюсеров.
Тогда нам нужно добавлять эти редьюсеры асинхронно, на этапе тестирования.
Т.е. в componentRender передавать в StoreProvider asyncReducers.
Так же нужно учитывать, что есть useInitialEffect, из-за него фетчинг данных и лоадеры.
Нужно делать его по условию __PROJECT__ !== 'jest' (мы сделали так в useInitialEffect).
Еще лучше вариант замокать запрос и тогда мы бы тестировали реальное поведение компонента.

Установили библиотеку @testing-library/user-event для более лучшего тестирования события пользователя.
Так же нужно учитывать что экшены userEvent асинхронные, их нужно await-ить.

Можно запускать тэсты с флагом -- --watch, так тесты будут перезапускаться при изменении файла.
Для проверки выполнения успешности запроса в unit тестах, его нужно замокать.
У нас используется инстанс api (от axios). api.put(). Можно использовать jest.spyOn().

В проекте на элементах есть атрибут data-testid и он нужен только для RTL тестов.
После сборки видно, что в DOM-нодах этот атрибут остаётся.
Причем он есть как в dev, так и в prod бандлах.
Каждый символ весит какое-то количество байт и от этих id бандл немного прибавляет в весе.

Тесты на роутер.
Нужно тестировать роуты авторизованного пользователя, по ролям, 404 страница, forbidden page, открытие страницы.
Написали рядом файл src/app/providers/router/ui/AppRouter.test.tsx
Повесили на Page атрибуты data-testid для их поиска при тестировании.
Создали отдельный интерфейс TestProps, чтоб расширять нужные элементы без необходимости явного указания в каждом компоненте.
Если нужно будет, можно расширить этот интерфейс.
В тестах используем не getByTestId, а findByTestId, т.к. компоненты загружаются асинхронно.
Если хочется запускать тесты прям из вебшторма, то нужно указать в настройках плагина путь до конфига jest, т.к. webstorm автоматически найти его не может.
