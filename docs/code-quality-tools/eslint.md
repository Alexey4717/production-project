К настройкам правил нужно относиться серьезно и основательно
npm install --save-dev eslint
npm init @eslint/config
Для настройки правил eslint, наводим на ошибку линта, копируем название правила и гуглим этот rule,
потом вставляем эти правила в .eslintrc.js в поле rules
Если мы знаем что это за правило и оно нам не нужно,
то можно просто указать его название в ключе rules со значением 'off'.
Либо можно сменить отображение на предупреждение (значение 'warn')
Команда eslint "**/*.{ts,tsx}" --fix должна фиксить все ошибки на проекте
Если осознанно хочется заблокировать правило в одном месте, можно над ним вставлять комментарий
// eslint-disable-next-line <название правила>

Для подсветки текста в jsx разметки для i18n (что нужен перевод) установлен eslint-plugin-i18next

Есть linter правила для react хуков (https://legacy.reactjs.org/docs/hooks-rules.html#eslint-plugin) - есть в CRA по дефолту.
Поставили правило 'react-hooks/exhaustive-deps': 'error' для массивов зависимостей react хуков.
С ним будут подсказки, что в массиве зависимостей отсутствуют нужные зависимости либо присутствуют лишние.

Переменная __API__ будет задаваться на этапе сборки приложения (config/builds/).
В eslintrc.js __API__: true, (Чтобы он не ругался).

Есть свойство "no-undef" в eslint. Это свойство предотвращает использование каких-то глобальных переменных, типов.
Отключили это правило, т.к. оно в основном используется с var, а мы его не используем.

Для buildPlugins расширили входные аргументы, передали project: 'storybook' | 'frontend' | 'jest'.
в eslint.rc добавили __PROJECT__: true, чтобы линтер не ругался.

Есть плагин для линта eslint-plugin-unused-imports, установили его как devDep.
Добавили в конфиг в массив plugins unused-imports. В rules 'unused-imports/no-unused-imports': 'error'.
Еще есть популярный плагин eslint-plugin-import.
Можно делать особый порядок (сначала с библиотек, потом с исходников абсолютные и относительные, можно отдельно импорт типов, пробелы между ними).

## Создание своих плагинов.
Создали новую директорию для проекта. npm init -y.
Плагин обязательно должен называться с eslint-plugin.
Для того чтоб установить плагин, можно руками все установить и добавить (есть описания в документации).
Но уже есть готовые решения, которые позволяют всю необходимую структуру сгенерировать.
Выбрали пакет eslint-generator. Для этого установили глобально npm i -g yo и eslint-generator.
Это пакет для инициализации проектов, для создания опросников (типа добавить ts? добавить react?).
Вероятно он стоит например в CRA или подобных средах, когда разворачиваем приложение.
После установки выполняем команду yo eslint:plugin. Указываем имя, название плагина, описание, содержит eslint правила - да.
Перезапишет package.json. Сгенерируется структура.
В папке lib/index.js скрипт все правила из папки rules импортирует, потом экспортирует.
Для создания правила yo eslint:rule. Т.е. плагин может содержать в себе много правил.
Создали плагин path-checker. Это правило будет проверять правильность указания абсолютных и относительных импортов.
Сначала создадим по-простому только относительные, потом допишем и изменим.
В папке rules сгенерился новый файл (можно поудалять комменты).
Работаем в методе create, выше указаны метаданные.
Так же сгенерился одноименный файл с тестами в соответствующей папке.
Там можно описывать как валидные, так и невалидные сценарии.
Т.е. указывается код, запускаются тесты (уже есть скрипт в package.json) линтер этот код через правила пропускает (легко дебажить).

В работе с созданием плагинов можно пользоваться AST (абстрактное синтаксическое дерево).
Пример в astexplorer.net. Туда вставляется слева код.
Если выделять куски кода слева, то справа будет появляться информация о парсинге (ноды).
Например, можно слева добавить импорт и справа посмотреть формирование нод.
Пример создания плагина https://eslint.org/docs/latest/extend/custom-rules

В конце разработки плагина, нужно сделать publish в npm.
Во-первых, нужно залогиниться, создать аккаунт на сайте npm.
Потом в терминале npm login.
Потом npm publish.
После чего на сайте npm в packages появится опубликованный пакет.
Установим его на проекте как дев замисимость.
В файле .eslintrc.js указываем его в plugins, потом в rules 'alexey4717-plugin/path-checker': 'error'.
После внесения правок в плагин, нужно увеличить версию 0.0.1 и снова npm publish.
Потом на основном проекте обновить версию, заругается линтер.

В файле shared/config/storybook/StoreDecorator есть ошибки из нового плагина, которых быть не должно.
Помимо продакшен кода, который пользователь видит в браузере,
У нас есть вспомогательный код для разработки (тесты, сторисы и т.п.).
Для таких файлов будем создавать отдельный файл с publicApi, который будет называться testing.ts.
Там будет импорт вспомогательного кода, который не нужен в проде (экшены, редьюсеры и т.п.).
И такой код (благодаря линтеру) не получится импортить в продакшен коде из тестового паблик апи.
В таких файлах будет импорт не такой
import { loginReducer } from '@/features/AuthByUsername/model/slice/loginSlice'
а такой
import { loginReducer } from '@/features/AuthByUsername/testing'
Подготовили линтер, чтоб на testing api он не ругался.
Но, чтобы мы случайно в наш код не затащили какие-то моки или редьюсер, который там не нужен,
нам необходимо понимать, какие файлы являются тестовыми.
Определять мы это будет не на уровне самого плагина, а через передачу внешних параметров в файле eslintrc.
Передали в плагин testFilesPatterns: ['**/*.test.*', '**/*.story.*', '**/StoreDecorator.tsx'].
Т.е. если захотим поменять расширение файлов на testing например, то просто изменим параметры для передачи в плагин.
Чтобы при этом не пришлось лезть в код плагина и менять это руками там.
В плагине добавили проверку, чтоб не выбрасывать ошибку импорта из index.ts publucApi в тестовых файлах.
И плюс проверку для тестовых файлов, что импорт не из publicApi (testing.ts).
Воспользуемся библиотекой micromatch, для работы с путями, globs.
Globs - паттерны для работы с путями.
Поле fixable: 'code', чтобы автоматически он исправлялся

