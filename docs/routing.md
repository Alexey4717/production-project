Несуществующий роут, page компонент для роута, которого нет в Routes

Добавили декоратор роутера

Для RouterProvider был вынесен конфиг в shared, т.к. роуты используются всеми уровнями компонентов.

Так же, если разлогиниться, но в карточке профиля будет ошибка (т.к. контент доступен только авторизованным пользователям).
Для этого реализован PrivateRoute. Пока сделали по колхозному, в конфиг добавили поле authOnly, по условию которого рендер.

Router v6 private protectеd routes. Защищенные маршруты.
Несколько уроков назад был реалирован роут, защищенный (только для авторизованного пользователя).
Если на него зайти, то тут 404 роут, это нарушает пользовательский опыт (ux).
Пользователю не всегда понятно, почему роут иногда доступен, а иногда 404.
По-хорошему для таких роутов надо делать редирект.
Создали компонент RequireAuth, который (как мидлвар) проверяет, если isAuth то рендерит children, иначе редирект на main.
Обернули этим компонентом роуты, по условию authOnly.
Так же был ньюанс, что AppRouter инициализировался раньше, чем мы получали данные о пользователе.
Получалось, что на момент когда 1 раз отрендерился AppRouter, мы еще не авторизованы.
Добавили в схему User флаг _inited, который показывает, что пользователь проинициализирован (в редьюсере initAuthData).
В корневом App.tsx отрисовываем Router только если _inited === true (т.е. данные о пользователе получены и мы точно знаем авторизован он или нет).

Создали 2 page (ArticlesPage - список, ArticleDetailsPage - одна статья).
Роуты /articles и /articles/:id. (Множественное число для еденичной сущности лучше масштабируется и следует правилам rest).
При переходе на роут /articles/123 была проблема, что браузер пытается запросить чанк,
т.е. в строке запроса появляется лишний articles (должен запросить из корня, а запрашивает из articles, а у нас такой папки нет).
Т.е. такие статические файлы по факту запрашиваются из папки build, в которую мы делаем сборку.
Просто в dev режиме эта папка не создается, эти файлы все хранятся в памяти (описания в buildWebpackConfig.ts в поле output).
Нужно добавить publicPath в output

## Пояснение от себя (что нагуглил):
При переходе на роут /articles/123, браузер интерпретирует путь /articles как базовую директорию для запросов к статическим файлам.
Поэтому, вместо того чтобы запросить файл main.a20f058c4f8f5bf80443.js из корня (/main.a20f058c4f8f5bf80443.js),
он делает запрос по неправильному пути: /articles/main.a20f058c4f8f5bf80443.js.
Это происходит из-за особенностей работы браузера с относительными путями к статическим ресурсам,
когда путь для запросов определяется текущим маршрутом.

В режиме разработки (dev-сервер Webpack):
Статические файлы не хранятся на диске. Они предоставляются из памяти (in-memory) dev-сервера.
Dev-сервер настроен так, чтобы корректно обрабатывать любые запросы и возвращать соответствующие файлы,
даже если путь содержит дополнительные сегменты (например, /articles/123).

В режиме production (после сборки):
Статические файлы сохраняются в папке build, и сервер должен их предоставлять из этой папки.
Сервер обычно обслуживает файлы строго в соответствии с указанным путём,
поэтому запросы по неверным путям (например, /articles/main.a20f058c4f8f5bf80443.js) приводят к ошибке 404.

## Апгрейд сайдбара. Селекторы.
Сейчас при попытке перейти в профиль формируется роут /profile/ и не загружается свой профиль.
Решили формировать массив ссылок для сайдбара в селекторе редакса, подставлять там id текущего пользователя.
Воспользовались createSelector из редакса, чтобы переиспользовать селектор и создать на основе него другой для сайдбара.


Так же есть еще ньюанс, что когда фильтры переключаются их состояние нигде не сохраняется и при перезагрузке страницы они сбрасываются на дефолтные.
Реализовали подставление состояния выбранных фильтров в строку роута.
Мы сможем так же ссылку передавать с фильтрами или сохранять.
Воспользовались стандартным api браузера window.history.pushState.
Чтобы удобно работать с этими параметрами можно использовать готовое решение из react-router-dom или другое готовое решение, но мы сделали своё.
Добавили shared/lib/url/addQueryParams. В папке url все хелперы для работы со строкой запроса.
Использовали useSearchParams из реакт роутера для отображения параметров из урл при инициализации компонента (в initArticlesPage).
Судя по документации json server можно отправлять фильтры по вложенных полям типа ?author.name=aleksei


Далее создали новую страницу (админ панель), доступ к которой будут иметь только админы.
Добавили роут. В AppRoutesProps добавили roles.
Добавили пункт админка в навбаре. Сделали запрос в AppRouter (чтоб нельзя было вручную в роут перейти через url).
Проверку по ролям можно сделать как в RequireAuth (мы сделали так), так и в отдельном компоненте.

Для пользователя редиректы (при отсутствии права) крайне неочевидны.
Тут по-хорошему надо отрисовывать дополнительный интерфейс, явно писать что пользователю запрещено посещать этот контент.
Для этого создали ForbiddenPage.

## Рефакторинг конфига роутера.
В shared/config/routeConfig есть определённые нарушения архитектуры.
Во-первых, импортируются pages из вышележащих слоёв в нижележащие.
Во-вторых, не очень удобный синтаксис.
Создали папку с конфигом на уровне роутера в App, т.к. он все равно используется только там.
Перенесли RouteConfig туда. Остались в shared enums, типы и константы для роутера.
В shared/types создали файл с типами.
И в shared/consts/router.ts файл с константами.
для типа используется UserRole из слоя entities, который так же вышележащий.
Пока оставим так, может потом вынесем этот тип в shared.

## Улучшаем и стандартизируем работу с роутером.
В некоторых местах приходится формировать маршруты примерно так
${RoutePaths.article_details}${article.id}/edit
Это не совсем удобно.
Сформировали роуты в виде функций const getRouteProfile = (id: string) => `/profile/${id}`
Чтоб не склеивать строки из разных кусков в разных местах.
Будем вызывать функции, передадим аргумент и будем уверены что сформируется правильный маршрут.
Для константы RoutePaths формироваться будет так getRouteProfile(':id'), а для реальных маршрутов будет передаваться реальный id.
В routeConfig и в компонентах заюзали все эти функции вместо RoutePaths.
При ручной склейке можно лишний слеш добавить или наоборот пропустить и в целом неудобно пользоваться и искать.

## Тесты на роутер. Обновляем RTL.
Нужно тестировать роуты авторизованного пользователя, по ролям, 404 страница, forbidden page, открытие страницы.
Написали рядом файл src/app/providers/router/ui/AppRouter.test.tsx
Повесили на Page атрибуты data-testid для их поиска при тестировании.
Создали отдельный интерфейс TestProps, чтоб расширять нужные элементы без необходимости явного указания в каждом компоненте.
Если нужно будет, можно расширить этот интерфейс.
В тесах используем не getByTestId, а findByTestId, т.к. компоненты загружаются асинхронно.
Но это изначально не помогло, т.к. нужно было обновить RTL пакет (после обновления версии реакта это необходимо было сделать).

## Облачный хостинг
Еще есть ньюанс, если перейти на вложенный роут (например /about) и перезагрузить страницу, то вернется 404.
Поскольку это SPA и index.html файл всего один.
Нужно чтобы все запросы отправлялись именно в этот единственный index.html файл.
А роутинг будет за счет react-router.
Нужно поправить конфиг nginx.

В shared/lib/router/useRouteChange хук, который следит за изменением маршрута и возвращает семантически понятное название текущего маршрута.

